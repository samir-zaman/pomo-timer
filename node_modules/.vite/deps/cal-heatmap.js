import {
  Accent_default,
  Blues_default,
  BrBG_default,
  BuGn_default,
  BuPu_default,
  Dark2_default,
  GnBu_default,
  Greens_default,
  Greys_default,
  InternSet,
  OrRd_default,
  Oranges_default,
  PRGn_default,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  PiYG_default,
  PuBuGn_default,
  PuBu_default,
  PuOr_default,
  PuRd_default,
  Purples_default,
  RdBu_default,
  RdGy_default,
  RdPu_default,
  RdYlBu_default,
  RdYlGn_default,
  Reds_default,
  Set1_default,
  Set2_default,
  Set3_default,
  Spectral_default,
  Tableau10_default,
  YlGnBu_default,
  YlGn_default,
  YlOrBr_default,
  YlOrRd_default,
  ascending,
  asterisk_default,
  band,
  category10_default,
  circle_default,
  cividis_default,
  cool,
  cross_default,
  csv,
  cubehelix_default,
  descending,
  diamond2_default,
  diamond_default,
  diverging,
  divergingLog,
  divergingPow,
  divergingSymlog,
  dsv,
  extent,
  hcl,
  hcl_default,
  hsl_default,
  identity,
  implicit,
  inferno,
  json_default,
  lab,
  linear,
  log,
  magma,
  max,
  median,
  min,
  number_default,
  ordinal,
  piecewise,
  plasma,
  plus_default,
  point,
  pow,
  quantile,
  quantile2,
  quantize_default,
  rainbow_default,
  range,
  reverse,
  rgb_default,
  round_default,
  scheme,
  scheme10,
  scheme11,
  scheme12,
  scheme13,
  scheme14,
  scheme15,
  scheme16,
  scheme17,
  scheme18,
  scheme19,
  scheme2,
  scheme20,
  scheme21,
  scheme22,
  scheme23,
  scheme24,
  scheme25,
  scheme26,
  scheme27,
  scheme3,
  scheme4,
  scheme5,
  scheme6,
  scheme7,
  scheme8,
  scheme9,
  second,
  select_default,
  sinebow_default,
  sort,
  square2_default,
  square_default,
  star_default,
  symbolsFill,
  symbolsStroke,
  symlog,
  text_default,
  threshold,
  ticks,
  time,
  timeDay,
  timeFriday,
  timeHour,
  timeMinute,
  timeMonday,
  timeMonth,
  timeSaturday,
  timeSunday,
  timeThursday,
  timeTuesday,
  timeWednesday,
  timeYear,
  times_default,
  triangle2_default,
  triangle_default,
  turbo_default,
  utcDay,
  utcFriday,
  utcHour,
  utcMinute,
  utcMonday,
  utcMonth,
  utcSaturday,
  utcSunday,
  utcThursday,
  utcTime,
  utcTuesday,
  utcWednesday,
  utcYear,
  viridis_default,
  warm,
  wye_default
} from "./chunk-ZX3RNAVT.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/cal-heatmap/dist/cal-heatmap.esm.js
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = false;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true) ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return exports2;
  };
  var exports2 = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty4 = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty4(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports2.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype2 = {};
  define(IteratorPrototype2, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values2([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype2 = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype2);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve2, reject2) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn3.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve2, reject2);
        }, function(err) {
          invoke("throw", err, resolve2, reject2);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve2(result);
        }, function(error) {
          return invoke("throw", error, resolve2, reject2);
        });
      }
      reject2(record.arg);
    }
    var previousPromise;
    defineProperty4(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve2, reject2) {
            invoke(method, arg, resolve2, reject2);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values2(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; ) if (hasOwn3.call(iterable, i)) return next3.value = iterable[i], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty4(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty4(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports2.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports2.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports2.keys = function(val) {
    var object = Object(val), keys4 = [];
    for (var key in object) keys4.push(key);
    return keys4.reverse(), function next2() {
      for (; keys4.length; ) {
        var key2 = keys4.pop();
        if (key2 in object) return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports2.values = values2, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn3.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values2(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports2;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var check = function(it) {
  return it && it.Math === Math && it;
};
var global$n = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
);
var shared$4 = { exports: {} };
var global$m = global$n;
var defineProperty$9 = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$9(global$m, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$m[key] = value;
  }
  return value;
};
var global$l = global$n;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$l[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$4.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.34.0",
  mode: "global",
  copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.34.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var sharedExports = shared$4.exports;
var fails$u = function(exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$t = fails$u;
var functionBindNative = !fails$t(function() {
  var test2 = (function() {
  }).bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var call$j = FunctionPrototype$3.call;
var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$3.bind.bind(call$j, call$j);
var functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$j.apply(fn, arguments);
  };
};
var isNullOrUndefined$8 = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$7 = isNullOrUndefined$8;
var $TypeError$g = TypeError;
var requireObjectCoercible$7 = function(it) {
  if (isNullOrUndefined$7(it)) throw new $TypeError$g("Can't call method on " + it);
  return it;
};
var requireObjectCoercible$6 = requireObjectCoercible$7;
var $Object$4 = Object;
var toObject$a = function(argument) {
  return $Object$4(requireObjectCoercible$6(argument));
};
var uncurryThis$u = functionUncurryThis;
var toObject$9 = toObject$a;
var hasOwnProperty$d = uncurryThis$u({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty$d(toObject$9(it), key);
};
var uncurryThis$t = functionUncurryThis;
var id$2 = 0;
var postfix = Math.random();
var toString$c = uncurryThis$t(1 .toString);
var uid$3 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$c(++id$2 + postfix, 36);
};
var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var global$k = global$n;
var userAgent$5 = engineUserAgent;
var process$3 = global$k.process;
var Deno$1 = global$k.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match;
var version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent$5) {
  match = userAgent$5.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$5.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION$3 = engineV8Version;
var fails$s = fails$u;
var global$j = global$n;
var $String$5 = global$j.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$s(function() {
  var symbol2 = Symbol("symbol detection");
  return !$String$5(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION$3 && V8_VERSION$3 < 41;
});
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var global$i = global$n;
var shared$3 = sharedExports;
var hasOwn$b = hasOwnProperty_1;
var uid$2 = uid$3;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var Symbol$3 = global$i.Symbol;
var WellKnownSymbolsStore = shared$3("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$3["for"] || Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$2;
var wellKnownSymbol$m = function(name) {
  if (!hasOwn$b(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$b(Symbol$3, name) ? Symbol$3[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore[name];
};
var wellKnownSymbol$l = wellKnownSymbol$m;
var TO_STRING_TAG$2 = wellKnownSymbol$l("toStringTag");
var test$1 = {};
test$1[TO_STRING_TAG$2] = "z";
var toStringTagSupport = String(test$1) === "[object z]";
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$o = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var objectDefineProperty = {};
var fails$r = fails$u;
var descriptors = !fails$r(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
});
var isCallable$n = isCallable$o;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$j = $documentAll.IS_HTMLDDA ? function(it) {
  return typeof it == "object" ? it !== null : isCallable$n(it) || it === documentAll;
} : function(it) {
  return typeof it == "object" ? it !== null : isCallable$n(it);
};
var global$h = global$n;
var isObject$i = isObject$j;
var document$3 = global$h.document;
var EXISTS$1 = isObject$i(document$3) && isObject$i(document$3.createElement);
var documentCreateElement$2 = function(it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};
var DESCRIPTORS$d = descriptors;
var fails$q = fails$u;
var createElement$1 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$d && !fails$q(function() {
  return Object.defineProperty(createElement$1("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
});
var DESCRIPTORS$c = descriptors;
var fails$p = fails$u;
var v8PrototypeDefineBug = DESCRIPTORS$c && fails$p(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype !== 42;
});
var isObject$h = isObject$j;
var $String$4 = String;
var $TypeError$f = TypeError;
var anObject$f = function(argument) {
  if (isObject$h(argument)) return argument;
  throw new $TypeError$f($String$4(argument) + " is not an object");
};
var NATIVE_BIND$2 = functionBindNative;
var call$i = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$i.bind(call$i) : function() {
  return call$i.apply(call$i, arguments);
};
var global$g = global$n;
var isCallable$m = isCallable$o;
var aFunction = function(argument) {
  return isCallable$m(argument) ? argument : void 0;
};
var getBuiltIn$7 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$g[namespace]) : global$g[namespace] && global$g[namespace][method];
};
var uncurryThis$s = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$s({}.isPrototypeOf);
var getBuiltIn$6 = getBuiltIn$7;
var isCallable$l = isCallable$o;
var isPrototypeOf$2 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var $Object$3 = Object;
var isSymbol$3 = USE_SYMBOL_AS_UID ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn$6("Symbol");
  return isCallable$l($Symbol) && isPrototypeOf$2($Symbol.prototype, $Object$3(it));
};
var $String$3 = String;
var tryToString$5 = function(argument) {
  try {
    return $String$3(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$k = isCallable$o;
var tryToString$4 = tryToString$5;
var $TypeError$e = TypeError;
var aCallable$a = function(argument) {
  if (isCallable$k(argument)) return argument;
  throw new $TypeError$e(tryToString$4(argument) + " is not a function");
};
var aCallable$9 = aCallable$a;
var isNullOrUndefined$6 = isNullOrUndefined$8;
var getMethod$4 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined$6(func) ? void 0 : aCallable$9(func);
};
var call$h = functionCall;
var isCallable$j = isCallable$o;
var isObject$g = isObject$j;
var $TypeError$d = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$j(fn = input.toString) && !isObject$g(val = call$h(fn, input))) return val;
  if (isCallable$j(fn = input.valueOf) && !isObject$g(val = call$h(fn, input))) return val;
  if (pref !== "string" && isCallable$j(fn = input.toString) && !isObject$g(val = call$h(fn, input))) return val;
  throw new $TypeError$d("Can't convert object to primitive value");
};
var call$g = functionCall;
var isObject$f = isObject$j;
var isSymbol$2 = isSymbol$3;
var getMethod$3 = getMethod$4;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$k = wellKnownSymbol$m;
var $TypeError$c = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$k("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$f(input) || isSymbol$2(input)) return input;
  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0) pref = "default";
    result = call$g(exoticToPrim, input, pref);
    if (!isObject$f(result) || isSymbol$2(result)) return result;
    throw new $TypeError$c("Can't convert object to primitive value");
  }
  if (pref === void 0) pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol$1 = isSymbol$3;
var toPropertyKey$3 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol$1(key) ? key : key + "";
};
var DESCRIPTORS$b = descriptors;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$e = anObject$f;
var toPropertyKey$2 = toPropertyKey$3;
var $TypeError$b = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$b ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$e(O);
  P = toPropertyKey$2(P);
  anObject$e(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor$1(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty2(O, P, Attributes) {
  anObject$e(O);
  P = toPropertyKey$2(P);
  anObject$e(Attributes);
  if (IE8_DOM_DEFINE$1) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) {
  }
  if ("get" in Attributes || "set" in Attributes) throw new $TypeError$b("Accessors not supported");
  if ("value" in Attributes) O[P] = Attributes.value;
  return O;
};
var makeBuiltIn$3 = { exports: {} };
var DESCRIPTORS$a = descriptors;
var hasOwn$a = hasOwnProperty_1;
var FunctionPrototype$2 = Function.prototype;
var getDescriptor = DESCRIPTORS$a && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$a(FunctionPrototype$2, "name");
var PROPER = EXISTS && (function something() {
}).name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$a || DESCRIPTORS$a && getDescriptor(FunctionPrototype$2, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$r = functionUncurryThis;
var isCallable$i = isCallable$o;
var store$1 = sharedStore;
var functionToString$1 = uncurryThis$r(Function.toString);
if (!isCallable$i(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString$1(it);
  };
}
var inspectSource$3 = store$1.inspectSource;
var global$f = global$n;
var isCallable$h = isCallable$o;
var WeakMap$3 = global$f.WeakMap;
var weakMapBasicDetection = isCallable$h(WeakMap$3) && /native code/.test(String(WeakMap$3));
var createPropertyDescriptor$4 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var DESCRIPTORS$9 = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$4;
var createNonEnumerableProperty$6 = DESCRIPTORS$9 ? function(object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var shared$2 = sharedExports;
var uid$1 = uid$3;
var keys$1 = shared$2("keys");
var sharedKey$3 = function(key) {
  return keys$1[key] || (keys$1[key] = uid$1(key));
};
var hiddenKeys$5 = {};
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$e = global$n;
var isObject$e = isObject$j;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$6;
var hasOwn$9 = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$4 = hiddenKeys$5;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$2 = global$e.TypeError;
var WeakMap$2 = global$e.WeakMap;
var set$2;
var get$1;
var has$1;
var enforce = function(it) {
  return has$1(it) ? get$1(it) : set$2(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$e(it) || (state = get$1(it)).type !== TYPE) {
      throw new TypeError$2("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared$1.state) {
  store = shared$1.state || (shared$1.state = new WeakMap$2());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set$2 = function(it, metadata) {
    if (store.has(it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get$1 = function(it) {
    return store.get(it) || {};
  };
  has$1 = function(it) {
    return store.has(it);
  };
} else {
  STATE = sharedKey$2("state");
  hiddenKeys$4[STATE] = true;
  set$2 = function(it, metadata) {
    if (hasOwn$9(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$5(it, STATE, metadata);
    return metadata;
  };
  get$1 = function(it) {
    return hasOwn$9(it, STATE) ? it[STATE] : {};
  };
  has$1 = function(it) {
    return hasOwn$9(it, STATE);
  };
}
var store;
var STATE;
var internalState = {
  set: set$2,
  get: get$1,
  has: has$1,
  enforce,
  getterFor
};
var uncurryThis$q = functionUncurryThis;
var fails$o = fails$u;
var isCallable$g = isCallable$o;
var hasOwn$8 = hasOwnProperty_1;
var DESCRIPTORS$8 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$2 = inspectSource$3;
var InternalStateModule$5 = internalState;
var enforceInternalState = InternalStateModule$5.enforce;
var getInternalState$3 = InternalStateModule$5.get;
var $String$2 = String;
var defineProperty$8 = Object.defineProperty;
var stringSlice$6 = uncurryThis$q("".slice);
var replace$3 = uncurryThis$q("".replace);
var join = uncurryThis$q([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS$8 && !fails$o(function() {
  return defineProperty$8(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {
  if (stringSlice$6($String$2(name), 0, 7) === "Symbol(") {
    name = "[" + replace$3($String$2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter) name = "get " + name;
  if (options && options.setter) name = "set " + name;
  if (!hasOwn$8(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    if (DESCRIPTORS$8) defineProperty$8(value, "name", { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$8(options, "arity") && value.length !== options.arity) {
    defineProperty$8(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$8(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$8) defineProperty$8(value, "prototype", { writable: false });
    } else if (value.prototype) value.prototype = void 0;
  } catch (error) {
  }
  var state = enforceInternalState(value);
  if (!hasOwn$8(state, "source")) {
    state.source = join(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$2(function toString() {
  return isCallable$g(this) && getInternalState$3(this).source || inspectSource$2(this);
}, "toString");
var makeBuiltInExports = makeBuiltIn$3.exports;
var isCallable$f = isCallable$o;
var definePropertyModule$3 = objectDefineProperty;
var makeBuiltIn$1 = makeBuiltInExports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$9 = function(O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$f(value)) makeBuiltIn$1(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) {
    }
    if (simple) O[key] = value;
    else definePropertyModule$3.f(O, key, {
      value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  }
  return O;
};
var uncurryThis$p = functionUncurryThis;
var toString$b = uncurryThis$p({}.toString);
var stringSlice$5 = uncurryThis$p("".slice);
var classofRaw$2 = function(it) {
  return stringSlice$5(toString$b(it), 8, -1);
};
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$e = isCallable$o;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$j = wellKnownSymbol$m;
var TO_STRING_TAG$1 = wellKnownSymbol$j("toStringTag");
var $Object$2 = Object;
var CORRECT_ARGUMENTS = classofRaw$1(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error) {
  }
};
var classof$b = TO_STRING_TAG_SUPPORT$2 ? classofRaw$1 : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object$2(it), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O) : (result = classofRaw$1(O)) === "Object" && isCallable$e(O.callee) ? "Arguments" : result;
};
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$a = classof$b;
var objectToString$2 = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
  return "[object " + classof$a(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineBuiltIn$8 = defineBuiltIn$9;
var toString$a = objectToString$2;
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn$8(Object.prototype, "toString", toString$a, { unsafe: true });
}
var objectGetOwnPropertyDescriptor = {};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$3(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$1;
var uncurryThis$o = functionUncurryThis;
var fails$n = fails$u;
var classof$9 = classofRaw$2;
var $Object$1 = Object;
var split = uncurryThis$o("".split);
var indexedObject = fails$n(function() {
  return !$Object$1("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$9(it) === "String" ? split(it, "") : $Object$1(it);
} : $Object$1;
var IndexedObject$3 = indexedObject;
var requireObjectCoercible$5 = requireObjectCoercible$7;
var toIndexedObject$9 = function(it) {
  return IndexedObject$3(requireObjectCoercible$5(it));
};
var DESCRIPTORS$7 = descriptors;
var call$f = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$2 = createPropertyDescriptor$4;
var toIndexedObject$8 = toIndexedObject$9;
var toPropertyKey$1 = toPropertyKey$3;
var hasOwn$7 = hasOwnProperty_1;
var IE8_DOM_DEFINE = ie8DomDefine;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$8(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) {
  }
  if (hasOwn$7(O, P)) return createPropertyDescriptor$2(!call$f(propertyIsEnumerableModule$1.f, O, P), O[P]);
};
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor$2 = Math.floor;
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor$2 : ceil)(n);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$4 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2(number);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var max$3 = Math.max;
var min$3 = Math.min;
var toAbsoluteIndex$4 = function(index, length2) {
  var integer = toIntegerOrInfinity$3(index);
  return integer < 0 ? max$3(integer + length2, 0) : min$3(integer, length2);
};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var min$2 = Math.min;
var toLength$3 = function(argument) {
  return argument > 0 ? min$2(toIntegerOrInfinity$2(argument), 9007199254740991) : 0;
};
var toLength$2 = toLength$3;
var lengthOfArrayLike$9 = function(obj) {
  return toLength$2(obj.length);
};
var toIndexedObject$7 = toIndexedObject$9;
var toAbsoluteIndex$3 = toAbsoluteIndex$4;
var lengthOfArrayLike$8 = lengthOfArrayLike$9;
var createMethod$4 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$7($this);
    var length2 = lengthOfArrayLike$8(O);
    var index = toAbsoluteIndex$3(fromIndex, length2);
    var value;
    if (IS_INCLUDES && el !== el) while (length2 > index) {
      value = O[index++];
      if (value !== value) return true;
    }
    else for (; length2 > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod$4(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod$4(false)
};
var uncurryThis$n = functionUncurryThis;
var hasOwn$6 = hasOwnProperty_1;
var toIndexedObject$6 = toIndexedObject$9;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$3 = hiddenKeys$5;
var push$4 = uncurryThis$n([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject$6(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn$6(hiddenKeys$3, key) && hasOwn$6(O, key) && push$4(result, key);
  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {
    ~indexOf$1(result, key) || push$4(result, key);
  }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$2);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$5 = getBuiltIn$7;
var uncurryThis$m = functionUncurryThis;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$d = anObject$f;
var concat$2 = uncurryThis$m([].concat);
var ownKeys$1 = getBuiltIn$5("Reflect", "ownKeys") || function ownKeys(it) {
  var keys4 = getOwnPropertyNamesModule$1.f(anObject$d(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols ? concat$2(keys4, getOwnPropertySymbols(it)) : keys4;
};
var hasOwn$5 = hasOwnProperty_1;
var ownKeys2 = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$2 = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys4 = ownKeys2(source);
  var defineProperty4 = definePropertyModule$2.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys4.length; i++) {
    var key = keys4[i];
    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$m = fails$u;
var isCallable$d = isCallable$o;
var replacement = /#|\.prototype\./;
var isForced$3 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true : value === NATIVE ? false : isCallable$d(detection) ? fails$m(detection) : !!detection;
};
var normalize = isForced$3.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$3.data = {};
var NATIVE = isForced$3.NATIVE = "N";
var POLYFILL = isForced$3.POLYFILL = "P";
var isForced_1 = isForced$3;
var global$d = global$n;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$6;
var defineBuiltIn$7 = defineBuiltIn$9;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced$2 = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$d;
  } else if (STATIC) {
    target = global$d[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$d[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor$2(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED2 = isForced$2(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    if (!FORCED2 && targetProperty !== void 0) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty$4(sourceProperty, "sham", true);
    }
    defineBuiltIn$7(target, key, sourceProperty, options);
  }
};
var global$c = global$n;
var classof$8 = classofRaw$2;
var engineIsNode = classof$8(global$c.process) === "process";
var uncurryThis$l = functionUncurryThis;
var aCallable$8 = aCallable$a;
var functionUncurryThisAccessor = function(object, key, method) {
  try {
    return uncurryThis$l(aCallable$8(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) {
  }
};
var isCallable$c = isCallable$o;
var $String$1 = String;
var $TypeError$a = TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$c(argument)) return argument;
  throw new $TypeError$a("Can't set " + $String$1(argument) + " as a prototype");
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var anObject$c = anObject$f;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O, proto) {
    anObject$c(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : void 0);
var defineProperty$7 = objectDefineProperty.f;
var hasOwn$4 = hasOwnProperty_1;
var wellKnownSymbol$i = wellKnownSymbol$m;
var TO_STRING_TAG = wellKnownSymbol$i("toStringTag");
var setToStringTag$5 = function(target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn$4(target, TO_STRING_TAG)) {
    defineProperty$7(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};
var makeBuiltIn = makeBuiltInExports;
var defineProperty$6 = objectDefineProperty;
var defineBuiltInAccessor$3 = function(target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty$6.f(target, name, descriptor);
};
var getBuiltIn$4 = getBuiltIn$7;
var defineBuiltInAccessor$2 = defineBuiltInAccessor$3;
var wellKnownSymbol$h = wellKnownSymbol$m;
var DESCRIPTORS$6 = descriptors;
var SPECIES$6 = wellKnownSymbol$h("species");
var setSpecies$2 = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);
  if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$6]) {
    defineBuiltInAccessor$2(Constructor, SPECIES$6, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var isPrototypeOf$1 = objectIsPrototypeOf;
var $TypeError$9 = TypeError;
var anInstance$4 = function(it, Prototype) {
  if (isPrototypeOf$1(Prototype, it)) return it;
  throw new $TypeError$9("Incorrect invocation");
};
var uncurryThis$k = functionUncurryThis;
var fails$l = fails$u;
var isCallable$b = isCallable$o;
var classof$7 = classof$b;
var getBuiltIn$3 = getBuiltIn$7;
var inspectSource$1 = inspectSource$3;
var noop = function() {
};
var empty = [];
var construct = getBuiltIn$3("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$1 = uncurryThis$k(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$b(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$b(argument)) return false;
  switch (classof$7(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource$1(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$4 = !construct || fails$l(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var isConstructor$3 = isConstructor$4;
var tryToString$3 = tryToString$5;
var $TypeError$8 = TypeError;
var aConstructor$1 = function(argument) {
  if (isConstructor$3(argument)) return argument;
  throw new $TypeError$8(tryToString$3(argument) + " is not a constructor");
};
var anObject$b = anObject$f;
var aConstructor = aConstructor$1;
var isNullOrUndefined$5 = isNullOrUndefined$8;
var wellKnownSymbol$g = wellKnownSymbol$m;
var SPECIES$5 = wellKnownSymbol$g("species");
var speciesConstructor$1 = function(O, defaultConstructor) {
  var C = anObject$b(O).constructor;
  var S;
  return C === void 0 || isNullOrUndefined$5(S = anObject$b(C)[SPECIES$5]) ? defaultConstructor : aConstructor(S);
};
var NATIVE_BIND$1 = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var apply$3 = FunctionPrototype$1.apply;
var call$e = FunctionPrototype$1.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$e.bind(apply$3) : function() {
  return call$e.apply(apply$3, arguments);
});
var classofRaw = classofRaw$2;
var uncurryThis$j = functionUncurryThis;
var functionUncurryThisClause = function(fn) {
  if (classofRaw(fn) === "Function") return uncurryThis$j(fn);
};
var uncurryThis$i = functionUncurryThisClause;
var aCallable$7 = aCallable$a;
var NATIVE_BIND = functionBindNative;
var bind$7 = uncurryThis$i(uncurryThis$i.bind);
var functionBindContext = function(fn, that) {
  aCallable$7(fn);
  return that === void 0 ? fn : NATIVE_BIND ? bind$7(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var getBuiltIn$2 = getBuiltIn$7;
var html$2 = getBuiltIn$2("document", "documentElement");
var uncurryThis$h = functionUncurryThis;
var arraySlice$3 = uncurryThis$h([].slice);
var $TypeError$7 = TypeError;
var validateArgumentsLength$1 = function(passed, required) {
  if (passed < required) throw new $TypeError$7("Not enough arguments");
  return passed;
};
var userAgent$4 = engineUserAgent;
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);
var global$b = global$n;
var apply$2 = functionApply;
var bind$6 = functionBindContext;
var isCallable$a = isCallable$o;
var hasOwn$3 = hasOwnProperty_1;
var fails$k = fails$u;
var html$1 = html$2;
var arraySlice$2 = arraySlice$3;
var createElement = documentCreateElement$2;
var validateArgumentsLength = validateArgumentsLength$1;
var IS_IOS$1 = engineIsIos;
var IS_NODE$3 = engineIsNode;
var set$1 = global$b.setImmediate;
var clear = global$b.clearImmediate;
var process$2 = global$b.process;
var Dispatch = global$b.Dispatch;
var Function$1 = global$b.Function;
var MessageChannel = global$b.MessageChannel;
var String$1 = global$b.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var $location;
var defer;
var channel;
var port;
fails$k(function() {
  $location = global$b.location;
});
var run = function(id2) {
  if (hasOwn$3(queue$2, id2)) {
    var fn = queue$2[id2];
    delete queue$2[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var eventListener = function(event) {
  run(event.data);
};
var globalPostMessageDefer = function(id2) {
  global$b.postMessage(String$1(id2), $location.protocol + "//" + $location.host);
};
if (!set$1 || !clear) {
  set$1 = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable$a(handler) ? handler : Function$1(handler);
    var args = arraySlice$2(arguments, 1);
    queue$2[++counter] = function() {
      apply$2(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id2) {
    delete queue$2[id2];
  };
  if (IS_NODE$3) {
    defer = function(id2) {
      process$2.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel && !IS_IOS$1) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind$6(port.postMessage, port);
  } else if (global$b.addEventListener && isCallable$a(global$b.postMessage) && !global$b.importScripts && $location && $location.protocol !== "file:" && !fails$k(globalPostMessageDefer)) {
    defer = globalPostMessageDefer;
    global$b.addEventListener("message", eventListener, false);
  } else if (ONREADYSTATECHANGE in createElement("script")) {
    defer = function(id2) {
      html$1.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
        html$1.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task$1 = {
  set: set$1,
  clear
};
var Queue$2 = function() {
  this.head = null;
  this.tail = null;
};
Queue$2.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      var next2 = this.head = entry.next;
      if (next2 === null) this.tail = null;
      return entry.item;
    }
  }
};
var queue$1 = Queue$2;
var userAgent$3 = engineUserAgent;
var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && typeof Pebble != "undefined";
var userAgent$2 = engineUserAgent;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);
var global$a = global$n;
var bind$5 = functionBindContext;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var Queue$1 = queue$1;
var IS_IOS = engineIsIos;
var IS_IOS_PEBBLE = engineIsIosPebble;
var IS_WEBOS_WEBKIT = engineIsWebosWebkit;
var IS_NODE$2 = engineIsNode;
var MutationObserver = global$a.MutationObserver || global$a.WebKitMutationObserver;
var document$2 = global$a.document;
var process$1 = global$a.process;
var Promise$3 = global$a.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$a, "queueMicrotask");
var microtask$1 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify$1;
var toggle;
var node;
var promise;
var then;
if (!microtask$1) {
  queue = new Queue$1();
  flush = function() {
    var parent, fn;
    if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error) {
      if (queue.head) notify$1();
      throw error;
    }
    if (parent) parent.enter();
  };
  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
    toggle = true;
    node = document$2.createTextNode("");
    new MutationObserver(flush).observe(node, { characterData: true });
    notify$1 = function() {
      node.data = toggle = !toggle;
    };
  } else if (!IS_IOS_PEBBLE && Promise$3 && Promise$3.resolve) {
    promise = Promise$3.resolve(void 0);
    promise.constructor = Promise$3;
    then = bind$5(promise.then, promise);
    notify$1 = function() {
      then(flush);
    };
  } else if (IS_NODE$2) {
    notify$1 = function() {
      process$1.nextTick(flush);
    };
  } else {
    macrotask = bind$5(macrotask, global$a);
    notify$1 = function() {
      macrotask(flush);
    };
  }
  microtask$1 = function(fn) {
    if (!queue.head) notify$1();
    queue.add(fn);
  };
}
var queue;
var flush;
var microtask_1 = microtask$1;
var hostReportErrors$1 = function(a, b) {
  try {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  } catch (error) {
  }
};
var perform$4 = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error) {
    return { error: true, value: error };
  }
};
var global$9 = global$n;
var promiseNativeConstructor = global$9.Promise;
var engineIsDeno = typeof Deno == "object" && Deno && typeof Deno.version == "object";
var IS_DENO$1 = engineIsDeno;
var IS_NODE$1 = engineIsNode;
var engineIsBrowser = !IS_DENO$1 && !IS_NODE$1 && typeof window == "object" && typeof document == "object";
var global$8 = global$n;
var NativePromiseConstructor$3 = promiseNativeConstructor;
var isCallable$9 = isCallable$o;
var isForced$1 = isForced_1;
var inspectSource = inspectSource$3;
var wellKnownSymbol$f = wellKnownSymbol$m;
var IS_BROWSER = engineIsBrowser;
var IS_DENO = engineIsDeno;
var V8_VERSION$2 = engineV8Version;
NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
var SPECIES$4 = wellKnownSymbol$f("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$9(global$8.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced$1("Promise", function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION$2 === 66) return true;
  if (!V8_VERSION$2 || V8_VERSION$2 < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    var promise2 = new NativePromiseConstructor$3(function(resolve2) {
      resolve2(1);
    });
    var FakePromise = function(exec2) {
      exec2(function() {
      }, function() {
      });
    };
    var constructor = promise2.constructor = {};
    constructor[SPECIES$4] = FakePromise;
    SUBCLASSING = promise2.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  }
  return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING
};
var newPromiseCapability$2 = {};
var aCallable$6 = aCallable$a;
var $TypeError$6 = TypeError;
var PromiseCapability = function(C) {
  var resolve2, reject2;
  this.promise = new C(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0) throw new $TypeError$6("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable$6(resolve2);
  this.reject = aCallable$6(reject2);
};
newPromiseCapability$2.f = function(C) {
  return new PromiseCapability(C);
};
var $$p = _export;
var IS_NODE = engineIsNode;
var global$7 = global$n;
var call$d = functionCall;
var defineBuiltIn$6 = defineBuiltIn$9;
var setPrototypeOf$2 = objectSetPrototypeOf;
var setToStringTag$4 = setToStringTag$5;
var setSpecies$1 = setSpecies$2;
var aCallable$5 = aCallable$a;
var isCallable$8 = isCallable$o;
var isObject$d = isObject$j;
var anInstance$3 = anInstance$4;
var speciesConstructor = speciesConstructor$1;
var task = task$1.set;
var microtask = microtask_1;
var hostReportErrors = hostReportErrors$1;
var perform$3 = perform$4;
var Queue = queue$1;
var InternalStateModule$4 = internalState;
var NativePromiseConstructor$2 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule$4.getterFor(PROMISE);
var setInternalState$4 = InternalStateModule$4.set;
var NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
var PromiseConstructor = NativePromiseConstructor$2;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1 = global$7.TypeError;
var document$1 = global$7.document;
var process = global$7.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$4.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$7.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal;
var OwnPromiseCapability;
var PromiseWrapper;
var nativeThen;
var isThenable = function(it) {
  var then2;
  return isObject$d(it) && isCallable$8(then2 = it.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state === FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(new TypeError$1("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        call$d(then2, result, resolve2, reject2);
      } else resolve2(result);
    } else reject2(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject2(error);
  }
};
var notify = function(state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};
var dispatchEvent = function(name, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name, false, true);
    global$7.dispatchEvent(event);
  } else event = { promise: promise2, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$7["on" + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  call$d(task, global$7, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform$3(function() {
        if (IS_NODE) {
          process.emit("unhandledRejection", value, promise2);
        } else dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  call$d(task, global$7, function() {
    var promise2 = state.facade;
    if (IS_NODE) {
      process.emit("rejectionHandled", promise2);
    } else dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind$4 = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw new TypeError$1("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask(function() {
        var wrapper = { done: false };
        try {
          call$d(
            then2,
            value,
            bind$4(internalResolve, wrapper, state),
            bind$4(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance$3(this, PromisePrototype);
    aCallable$5(executor);
    call$d(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$4(internalResolve, state), bind$4(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState$4(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: void 0
    });
  };
  Internal.prototype = defineBuiltIn$6(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable$8(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable$8(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : void 0;
    if (state.state === PENDING) state.reactions.add(reaction);
    else microtask(function() {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalPromiseState(promise2);
    this.promise = promise2;
    this.resolve = bind$4(internalResolve, state);
    this.reject = bind$4(internalReject, state);
  };
  newPromiseCapabilityModule$4.f = newPromiseCapability$1 = function(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
  if (isCallable$8(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {
    nativeThen = NativePromisePrototype$1.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      defineBuiltIn$6(NativePromisePrototype$1, "then", function then2(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve2, reject2) {
          call$d(nativeThen, that, resolve2, reject2);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
    }
    try {
      delete NativePromisePrototype$1.constructor;
    } catch (error) {
    }
    if (setPrototypeOf$2) {
      setPrototypeOf$2(NativePromisePrototype$1, PromisePrototype);
    }
  }
}
$$p({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
  Promise: PromiseConstructor
});
setToStringTag$4(PromiseConstructor, PROMISE, false);
setSpecies$1(PROMISE);
var iterators = {};
var wellKnownSymbol$e = wellKnownSymbol$m;
var Iterators$4 = iterators;
var ITERATOR$5 = wellKnownSymbol$e("iterator");
var ArrayPrototype$1 = Array.prototype;
var isArrayIteratorMethod$2 = function(it) {
  return it !== void 0 && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
};
var classof$6 = classof$b;
var getMethod$2 = getMethod$4;
var isNullOrUndefined$4 = isNullOrUndefined$8;
var Iterators$3 = iterators;
var wellKnownSymbol$d = wellKnownSymbol$m;
var ITERATOR$4 = wellKnownSymbol$d("iterator");
var getIteratorMethod$3 = function(it) {
  if (!isNullOrUndefined$4(it)) return getMethod$2(it, ITERATOR$4) || getMethod$2(it, "@@iterator") || Iterators$3[classof$6(it)];
};
var call$c = functionCall;
var aCallable$4 = aCallable$a;
var anObject$a = anObject$f;
var tryToString$2 = tryToString$5;
var getIteratorMethod$2 = getIteratorMethod$3;
var $TypeError$5 = TypeError;
var getIterator$2 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;
  if (aCallable$4(iteratorMethod)) return anObject$a(call$c(iteratorMethod, argument));
  throw new $TypeError$5(tryToString$2(argument) + " is not iterable");
};
var call$b = functionCall;
var anObject$9 = anObject$f;
var getMethod$1 = getMethod$4;
var iteratorClose$2 = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject$9(iterator);
  try {
    innerResult = getMethod$1(iterator, "return");
    if (!innerResult) {
      if (kind === "throw") throw value;
      return value;
    }
    innerResult = call$b(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === "throw") throw value;
  if (innerError) throw innerResult;
  anObject$9(innerResult);
  return value;
};
var bind$3 = functionBindContext;
var call$a = functionCall;
var anObject$8 = anObject$f;
var tryToString$1 = tryToString$5;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var lengthOfArrayLike$7 = lengthOfArrayLike$9;
var isPrototypeOf = objectIsPrototypeOf;
var getIterator$1 = getIterator$2;
var getIteratorMethod$1 = getIteratorMethod$3;
var iteratorClose$1 = iteratorClose$2;
var $TypeError$4 = TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate$6 = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind$3(unboundFunction, that);
  var iterator, iterFn, index, length2, result, next2, step;
  var stop = function(condition) {
    if (iterator) iteratorClose$1(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject$8(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod$1(iterable);
    if (!iterFn) throw new $TypeError$4(tryToString$1(iterable) + " is not iterable");
    if (isArrayIteratorMethod$1(iterFn)) {
      for (index = 0, length2 = lengthOfArrayLike$7(iterable); length2 > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      }
      return new Result(false);
    }
    iterator = getIterator$1(iterable, iterFn);
  }
  next2 = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call$a(next2, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose$1(iterator, "throw", error);
    }
    if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
  }
  return new Result(false);
};
var wellKnownSymbol$c = wellKnownSymbol$m;
var ITERATOR$3 = wellKnownSymbol$c("iterator");
var SAFE_CLOSING = false;
try {
  called = 0;
  iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR$3] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error) {
}
var called;
var iteratorWithReturn;
var checkCorrectnessOfIteration$3 = function(exec2, SKIP_CLOSING) {
  try {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  } catch (error) {
    return false;
  }
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR$3] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error) {
  }
  return ITERATION_SUPPORT;
};
var NativePromiseConstructor$1 = promiseNativeConstructor;
var checkCorrectnessOfIteration$2 = checkCorrectnessOfIteration$3;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$2(function(iterable) {
  NativePromiseConstructor$1.all(iterable).then(void 0, function() {
  });
});
var $$o = _export;
var call$9 = functionCall;
var aCallable$3 = aCallable$a;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$2 = perform$4;
var iterate$5 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration;
$$o({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$2 }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$3.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform$2(function() {
      var $promiseResolve = aCallable$3(C.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$5(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$9($promiseResolve, C, promise2).then(function(value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values2[index] = value;
          --remaining || resolve2(values2);
        }, reject2);
      });
      --remaining || resolve2(values2);
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$n = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromiseConstructor = promiseNativeConstructor;
var getBuiltIn$1 = getBuiltIn$7;
var isCallable$7 = isCallable$o;
var defineBuiltIn$5 = defineBuiltIn$9;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
$$n({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
  "catch": function(onRejected) {
    return this.then(void 0, onRejected);
  }
});
if (isCallable$7(NativePromiseConstructor)) {
  method = getBuiltIn$1("Promise").prototype["catch"];
  if (NativePromisePrototype["catch"] !== method) {
    defineBuiltIn$5(NativePromisePrototype, "catch", method, { unsafe: true });
  }
}
var method;
var $$m = _export;
var call$8 = functionCall;
var aCallable$2 = aCallable$a;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$1 = perform$4;
var iterate$4 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
$$m({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule$2.f(C);
    var reject2 = capability.reject;
    var result = perform$1(function() {
      var $promiseResolve = aCallable$2(C.resolve);
      iterate$4(iterable, function(promise2) {
        call$8($promiseResolve, C, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var $$l = _export;
var call$7 = functionCall;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
$$l({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule$1.f(this);
    call$7(capability.reject, void 0, r);
    return capability.promise;
  }
});
var anObject$7 = anObject$f;
var isObject$c = isObject$j;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$1 = function(C, x) {
  anObject$7(C);
  if (isObject$c(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve2 = promiseCapability.resolve;
  resolve2(x);
  return promiseCapability.promise;
};
var $$k = _export;
var getBuiltIn = getBuiltIn$7;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve = promiseResolve$1;
getBuiltIn("Promise");
$$k({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(this, x);
  }
});
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$3 = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};
var DESCRIPTORS$5 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$1 = objectDefineProperty;
var anObject$6 = anObject$f;
var toIndexedObject$5 = toIndexedObject$9;
var objectKeys$2 = objectKeys$3;
objectDefineProperties.f = DESCRIPTORS$5 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$6(O);
  var props = toIndexedObject$5(Properties);
  var keys4 = objectKeys$2(Properties);
  var length2 = keys4.length;
  var index = 0;
  var key;
  while (length2 > index) definePropertyModule$1.f(O, key = keys4[index++], props[key]);
  return O;
};
var anObject$5 = anObject$f;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$1 = hiddenKeys$5;
var html = html$2;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$1("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length2 = enumBugKeys.length;
  while (length2--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
  return NullProtoObject();
};
hiddenKeys$1[IE_PROTO$1] = true;
var objectCreate$1 = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$5(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO$1] = O;
  } else result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var wellKnownSymbol$b = wellKnownSymbol$m;
var create$3 = objectCreate$1;
var defineProperty$5 = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$b("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] === void 0) {
  defineProperty$5(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$3(null)
  });
}
var addToUnscopables$3 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var fails$j = fails$u;
var correctPrototypeGetter = !fails$j(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$2 = hasOwnProperty_1;
var isCallable$6 = isCallable$o;
var toObject$8 = toObject$a;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var $Object = Object;
var ObjectPrototype = $Object.prototype;
var objectGetPrototypeOf$1 = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
  var object = toObject$8(O);
  if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$6(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object ? ObjectPrototype : null;
};
var fails$i = fails$u;
var isCallable$5 = isCallable$o;
var isObject$b = isObject$j;
var getPrototypeOf$1 = objectGetPrototypeOf$1;
var defineBuiltIn$4 = defineBuiltIn$9;
var wellKnownSymbol$a = wellKnownSymbol$m;
var ITERATOR$2 = wellKnownSymbol$a("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject$b(IteratorPrototype$2) || fails$i(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};
if (!isCallable$5(IteratorPrototype$2[ITERATOR$2])) {
  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate$1;
var createPropertyDescriptor$1 = createPropertyDescriptor$4;
var setToStringTag$3 = setToStringTag$5;
var Iterators$2 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor, NAME2, next2, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next2) });
  setToStringTag$3(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$2[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var $$j = _export;
var call$6 = functionCall;
var FunctionName = functionName;
var isCallable$4 = isCallable$o;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf = objectGetPrototypeOf$1;
var setPrototypeOf$1 = objectSetPrototypeOf;
var setToStringTag$2 = setToStringTag$5;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$6;
var defineBuiltIn$3 = defineBuiltIn$9;
var wellKnownSymbol$9 = wellKnownSymbol$m;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$9("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME2, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME2, next2);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys4() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries2() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME2 + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf$1) {
          setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$4(CurrentIteratorPrototype[ITERATOR$1])) {
          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      setToStringTag$2(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$1 && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$3(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$6(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);
      }
    }
    else $$j({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
  }
  Iterators$1[NAME2] = defaultIterator;
  return methods;
};
var createIterResultObject$3 = function(value, done) {
  return { value, done };
};
var toIndexedObject$4 = toIndexedObject$9;
var addToUnscopables$2 = addToUnscopables$3;
var Iterators = iterators;
var InternalStateModule$3 = internalState;
var defineProperty$4 = objectDefineProperty.f;
var defineIterator$2 = iteratorDefine;
var createIterResultObject$2 = createIterResultObject$3;
var DESCRIPTORS$4 = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState$2 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator$2(Array, "Array", function(iterated, kind) {
  setInternalState$3(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject$4(iterated),
    // target
    index: 0,
    // next index
    kind
    // kind
  });
}, function() {
  var state = getInternalState$2(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = void 0;
    return createIterResultObject$2(void 0, true);
  }
  switch (state.kind) {
    case "keys":
      return createIterResultObject$2(index, false);
    case "values":
      return createIterResultObject$2(target[index], false);
  }
  return createIterResultObject$2([index, target[index]], false);
}, "values");
var values = Iterators.Arguments = Iterators.Array;
addToUnscopables$2("keys");
addToUnscopables$2("values");
addToUnscopables$2("entries");
if (DESCRIPTORS$4 && values.name !== "values") try {
  defineProperty$4(values, "name", { value: "values" });
} catch (error) {
}
var $$i = _export;
var call$5 = functionCall;
var aCallable$1 = aCallable$a;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$4;
var iterate$3 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
$$i({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform(function() {
      var promiseResolve2 = aCallable$1(C.resolve);
      var values2 = [];
      var counter2 = 0;
      var remaining = 1;
      iterate$3(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        call$5(promiseResolve2, C, promise2).then(function(value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values2[index] = { status: "fulfilled", value };
          --remaining || resolve2(values2);
        }, function(error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values2[index] = { status: "rejected", reason: error };
          --remaining || resolve2(values2);
        });
      });
      --remaining || resolve2(values2);
    });
    if (result.error) reject2(result.value);
    return capability.promise;
  }
});
var classof$5 = classof$b;
var $String = String;
var toString$9 = function(argument) {
  if (classof$5(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return $String(argument);
};
var uncurryThis$g = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$8 = toString$9;
var requireObjectCoercible$4 = requireObjectCoercible$7;
var charAt$4 = uncurryThis$g("".charAt);
var charCodeAt = uncurryThis$g("".charCodeAt);
var stringSlice$4 = uncurryThis$g("".slice);
var createMethod$3 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S = toString$8(requireObjectCoercible$4($this));
    var position2 = toIntegerOrInfinity$1(pos);
    var size = S.length;
    var first, second2;
    if (position2 < 0 || position2 >= size) return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt(S, position2);
    return first < 55296 || first > 56319 || position2 + 1 === size || (second2 = charCodeAt(S, position2 + 1)) < 56320 || second2 > 57343 ? CONVERT_TO_STRING ? charAt$4(S, position2) : first : CONVERT_TO_STRING ? stringSlice$4(S, position2, position2 + 2) : (first - 55296 << 10) + (second2 - 56320) + 65536;
  };
};
var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$3(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$3(true)
};
var charAt$3 = stringMultibyte.charAt;
var toString$7 = toString$9;
var InternalStateModule$2 = internalState;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$1 = createIterResultObject$3;
var STRING_ITERATOR = "String Iterator";
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState$1 = InternalStateModule$2.getterFor(STRING_ITERATOR);
defineIterator$1(String, "String", function(iterated) {
  setInternalState$2(this, {
    type: STRING_ITERATOR,
    string: toString$7(iterated),
    index: 0
  });
}, function next() {
  var state = getInternalState$1(this);
  var string = state.string;
  var index = state.index;
  var point2;
  if (index >= string.length) return createIterResultObject$1(void 0, true);
  point2 = charAt$3(string, index);
  state.index += point2.length;
  return createIterResultObject$1(point2, false);
});
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$2 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$2 === Object.prototype ? void 0 : DOMTokenListPrototype$2;
var global$6 = global$n;
var DOMIterables$1 = domIterables;
var DOMTokenListPrototype$1 = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$6;
var setToStringTag$1 = setToStringTag$5;
var wellKnownSymbol$8 = wellKnownSymbol$m;
var ITERATOR = wellKnownSymbol$8("iterator");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype$1 = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty$2(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    setToStringTag$1(CollectionPrototype, COLLECTION_NAME, true);
    if (DOMIterables$1[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty$2(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};
for (COLLECTION_NAME$1 in DOMIterables$1) {
  handlePrototype$1(global$6[COLLECTION_NAME$1] && global$6[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);
}
var COLLECTION_NAME$1;
handlePrototype$1(DOMTokenListPrototype$1, "DOMTokenList");
var toObject$7 = toObject$a;
var toAbsoluteIndex$2 = toAbsoluteIndex$4;
var lengthOfArrayLike$6 = lengthOfArrayLike$9;
var arrayFill = function fill(value) {
  var O = toObject$7(this);
  var length2 = lengthOfArrayLike$6(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex$2(argumentsLength > 1 ? arguments[1] : void 0, length2);
  var end = argumentsLength > 2 ? arguments[2] : void 0;
  var endPos = end === void 0 ? length2 : toAbsoluteIndex$2(end, length2);
  while (endPos > index) O[index++] = value;
  return O;
};
var $$h = _export;
var fill2 = arrayFill;
var addToUnscopables$1 = addToUnscopables$3;
$$h({ target: "Array", proto: true }, {
  fill: fill2
});
addToUnscopables$1("fill");
var classof$4 = classofRaw$2;
var isArray$5 = Array.isArray || function isArray(argument) {
  return classof$4(argument) === "Array";
};
var toPropertyKey = toPropertyKey$3;
var definePropertyModule = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$4;
var createProperty$4 = function(object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};
var fails$h = fails$u;
var wellKnownSymbol$7 = wellKnownSymbol$m;
var V8_VERSION$1 = engineV8Version;
var SPECIES$3 = wellKnownSymbol$7("species");
var arrayMethodHasSpeciesSupport$4 = function(METHOD_NAME) {
  return V8_VERSION$1 >= 51 || !fails$h(function() {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$3] = function() {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};
var $$g = _export;
var isArray$4 = isArray$5;
var isConstructor$2 = isConstructor$4;
var isObject$a = isObject$j;
var toAbsoluteIndex$1 = toAbsoluteIndex$4;
var lengthOfArrayLike$5 = lengthOfArrayLike$9;
var toIndexedObject$3 = toIndexedObject$9;
var createProperty$3 = createProperty$4;
var wellKnownSymbol$6 = wellKnownSymbol$m;
var arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$4;
var nativeSlice = arraySlice$3;
var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$3("slice");
var SPECIES$2 = wellKnownSymbol$6("species");
var $Array$3 = Array;
var max$2 = Math.max;
$$g({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
  slice: function slice(start, end) {
    var O = toIndexedObject$3(this);
    var length2 = lengthOfArrayLike$5(O);
    var k = toAbsoluteIndex$1(start, length2);
    var fin = toAbsoluteIndex$1(end === void 0 ? length2 : end, length2);
    var Constructor, result, n;
    if (isArray$4(O)) {
      Constructor = O.constructor;
      if (isConstructor$2(Constructor) && (Constructor === $Array$3 || isArray$4(Constructor.prototype))) {
        Constructor = void 0;
      } else if (isObject$a(Constructor)) {
        Constructor = Constructor[SPECIES$2];
        if (Constructor === null) Constructor = void 0;
      }
      if (Constructor === $Array$3 || Constructor === void 0) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === void 0 ? $Array$3 : Constructor)(max$2(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$3(result, n, O[k]);
    result.length = n;
    return result;
  }
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j;
      for (i = 0; i < length2; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var EventEmitter = getDefaultExportFromCjs(eventemitter3Exports);
var isArray$2 = Array.isArray;
var isArray$3 = isArray$2;
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray$3(value) ? value : [value];
}
var isArray$1 = isArray$5;
var isConstructor$1 = isConstructor$4;
var isObject$9 = isObject$j;
var wellKnownSymbol$5 = wellKnownSymbol$m;
var SPECIES$1 = wellKnownSymbol$5("species");
var $Array$2 = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C;
  if (isArray$1(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor$1(C) && (C === $Array$2 || isArray$1(C.prototype))) C = void 0;
    else if (isObject$9(C)) {
      C = C[SPECIES$1];
      if (C === null) C = void 0;
    }
  }
  return C === void 0 ? $Array$2 : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$2 = function(originalArray, length2) {
  return new (arraySpeciesConstructor(originalArray))(length2 === 0 ? 0 : length2);
};
var bind$2 = functionBindContext;
var uncurryThis$f = functionUncurryThis;
var IndexedObject$2 = indexedObject;
var toObject$6 = toObject$a;
var lengthOfArrayLike$4 = lengthOfArrayLike$9;
var arraySpeciesCreate$1 = arraySpeciesCreate$2;
var push$3 = uncurryThis$f([].push);
var createMethod$2 = function(TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O = toObject$6($this);
    var self2 = IndexedObject$2(O);
    var length2 = lengthOfArrayLike$4(self2);
    var boundFunction = bind$2(callbackfn, that);
    var index = 0;
    var create3 = specificCreate || arraySpeciesCreate$1;
    var target = IS_MAP ? create3($this, length2) : IS_FILTER || IS_FILTER_REJECT ? create3($this, 0) : void 0;
    var value, result;
    for (; length2 > index; index++) if (NO_HOLES || index in self2) {
      value = self2[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result;
        else if (result) switch (TYPE) {
          case 3:
            return true;
          case 5:
            return value;
          case 6:
            return index;
          case 2:
            push$3(target, value);
        }
        else switch (TYPE) {
          case 4:
            return false;
          case 7:
            push$3(target, value);
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$2(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod$2(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod$2(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod$2(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod$2(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod$2(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$2(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod$2(7)
};
var $$f = _export;
var $map = arrayIteration.map;
var arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$4;
var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$2("map");
$$f({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
  map: function map(callbackfn) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var DESCRIPTORS$3 = descriptors;
var uncurryThis$e = functionUncurryThis;
var call$4 = functionCall;
var fails$g = fails$u;
var objectKeys$1 = objectKeys$3;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$5 = toObject$a;
var IndexedObject$1 = indexedObject;
var $assign = Object.assign;
var defineProperty$3 = Object.defineProperty;
var concat$1 = uncurryThis$e([].concat);
var objectAssign = !$assign || fails$g(function() {
  if (DESCRIPTORS$3 && $assign({ b: 1 }, $assign(defineProperty$3({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$3(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  var A = {};
  var B = {};
  var symbol2 = Symbol("assign detection");
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol2] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol2] !== 7 || objectKeys$1($assign({}, B)).join("") !== alphabet;
}) ? function assign(target, source) {
  var T = toObject$5(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable3 = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject$1(arguments[index++]);
    var keys4 = getOwnPropertySymbols ? concat$1(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
    var length2 = keys4.length;
    var j = 0;
    var key;
    while (length2 > j) {
      key = keys4[j++];
      if (!DESCRIPTORS$3 || call$4(propertyIsEnumerable3, S, key)) T[key] = S[key];
    }
  }
  return T;
} : $assign;
var $$e = _export;
var assign2 = objectAssign;
$$e({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
  assign: assign2
});
var internalMetadata = { exports: {} };
var objectGetOwnPropertyNamesExternal = {};
var toAbsoluteIndex = toAbsoluteIndex$4;
var lengthOfArrayLike$3 = lengthOfArrayLike$9;
var createProperty$2 = createProperty$4;
var $Array$1 = Array;
var max$1 = Math.max;
var arraySliceSimple = function(O, start, end) {
  var length2 = lengthOfArrayLike$3(O);
  var k = toAbsoluteIndex(start, length2);
  var fin = toAbsoluteIndex(end === void 0 ? length2 : end, length2);
  var result = $Array$1(max$1(fin - k, 0));
  var n = 0;
  for (; k < fin; k++, n++) createProperty$2(result, n, O[k]);
  result.length = n;
  return result;
};
var classof$3 = classofRaw$2;
var toIndexedObject$2 = toIndexedObject$9;
var $getOwnPropertyNames = objectGetOwnPropertyNames.f;
var arraySlice$1 = arraySliceSimple;
var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice$1(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames2(it) {
  return windowNames && classof$3(it) === "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject$2(it));
};
var fails$f = fails$u;
var arrayBufferNonExtensible = fails$f(function() {
  if (typeof ArrayBuffer == "function") {
    var buffer = new ArrayBuffer(8);
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
  }
});
var fails$e = fails$u;
var isObject$8 = isObject$j;
var classof$2 = classofRaw$2;
var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES$1 = fails$e(function() {
  $isExtensible(1);
});
var objectIsExtensible = FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
  if (!isObject$8(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$2(it) === "ArrayBuffer") return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;
var fails$d = fails$u;
var freezing = !fails$d(function() {
  return Object.isExtensible(Object.preventExtensions({}));
});
var $$d = _export;
var uncurryThis$d = functionUncurryThis;
var hiddenKeys = hiddenKeys$5;
var isObject$7 = isObject$j;
var hasOwn$1 = hasOwnProperty_1;
var defineProperty$2 = objectDefineProperty.f;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;
var isExtensible2 = objectIsExtensible;
var uid = uid$3;
var FREEZING = freezing;
var REQUIRED = false;
var METADATA = uid("meta");
var id$1 = 0;
var setMetadata = function(it) {
  defineProperty$2(it, METADATA, { value: {
    objectID: "O" + id$1++,
    // object ID
    weakData: {}
    // weak collections IDs
  } });
};
var fastKey$1 = function(it, create3) {
  if (!isObject$7(it)) return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
  if (!hasOwn$1(it, METADATA)) {
    if (!isExtensible2(it)) return "F";
    if (!create3) return "E";
    setMetadata(it);
  }
  return it[METADATA].objectID;
};
var getWeakData$1 = function(it, create3) {
  if (!hasOwn$1(it, METADATA)) {
    if (!isExtensible2(it)) return true;
    if (!create3) return false;
    setMetadata(it);
  }
  return it[METADATA].weakData;
};
var onFreeze = function(it) {
  if (FREEZING && REQUIRED && isExtensible2(it) && !hasOwn$1(it, METADATA)) setMetadata(it);
  return it;
};
var enable = function() {
  meta.enable = function() {
  };
  REQUIRED = true;
  var getOwnPropertyNames3 = getOwnPropertyNamesModule.f;
  var splice2 = uncurryThis$d([].splice);
  var test2 = {};
  test2[METADATA] = 1;
  if (getOwnPropertyNames3(test2).length) {
    getOwnPropertyNamesModule.f = function(it) {
      var result = getOwnPropertyNames3(it);
      for (var i = 0, length2 = result.length; i < length2; i++) {
        if (result[i] === METADATA) {
          splice2(result, i, 1);
          break;
        }
      }
      return result;
    };
    $$d({ target: "Object", stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};
var meta = internalMetadata.exports = {
  enable,
  fastKey: fastKey$1,
  getWeakData: getWeakData$1,
  onFreeze
};
hiddenKeys[METADATA] = true;
var internalMetadataExports = internalMetadata.exports;
var isCallable$3 = isCallable$o;
var isObject$6 = isObject$j;
var setPrototypeOf = objectSetPrototypeOf;
var inheritIfRequired$1 = function($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable$3(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$6(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};
var $$c = _export;
var global$5 = global$n;
var uncurryThis$c = functionUncurryThis;
var isForced = isForced_1;
var defineBuiltIn$2 = defineBuiltIn$9;
var InternalMetadataModule = internalMetadataExports;
var iterate$2 = iterate$6;
var anInstance$2 = anInstance$4;
var isCallable$2 = isCallable$o;
var isNullOrUndefined$3 = isNullOrUndefined$8;
var isObject$5 = isObject$j;
var fails$c = fails$u;
var checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$3;
var setToStringTag = setToStringTag$5;
var inheritIfRequired = inheritIfRequired$1;
var collection$3 = function(CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
  var ADDER = IS_MAP ? "set" : "add";
  var NativeConstructor = global$5[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};
  var fixMethod = function(KEY) {
    var uncurriedNativeMethod = uncurryThis$c(NativePrototype[KEY]);
    defineBuiltIn$2(
      NativePrototype,
      KEY,
      KEY === "add" ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY === "delete" ? function(key) {
        return IS_WEAK && !isObject$5(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === "get" ? function get2(key) {
        return IS_WEAK && !isObject$5(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY === "has" ? function has2(key) {
        return IS_WEAK && !isObject$5(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set2(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };
  var REPLACE2 = isForced(
    CONSTRUCTOR_NAME,
    !isCallable$2(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails$c(function() {
      new NativeConstructor().entries().next();
    }))
  );
  if (REPLACE2) {
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
    var THROWS_ON_PRIMITIVES = fails$c(function() {
      instance.has(1);
    });
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration$1(function(iterable) {
      new NativeConstructor(iterable);
    });
    var BUGGY_ZERO = !IS_WEAK && fails$c(function() {
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function(dummy, iterable) {
        anInstance$2(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined$3(iterable)) iterate$2(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod("delete");
      fixMethod("has");
      IS_MAP && fixMethod("get");
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }
  exported[CONSTRUCTOR_NAME] = Constructor;
  $$c({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};
var defineBuiltIn$1 = defineBuiltIn$9;
var defineBuiltIns$2 = function(target, src, options) {
  for (var key in src) defineBuiltIn$1(target, key, src[key], options);
  return target;
};
var uncurryThis$b = functionUncurryThis;
var defineBuiltIns$1 = defineBuiltIns$2;
var getWeakData = internalMetadataExports.getWeakData;
var anInstance$1 = anInstance$4;
var anObject$4 = anObject$f;
var isNullOrUndefined$2 = isNullOrUndefined$8;
var isObject$4 = isObject$j;
var iterate$1 = iterate$6;
var ArrayIterationModule = arrayIteration;
var hasOwn2 = hasOwnProperty_1;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var internalStateGetterFor$1 = InternalStateModule$1.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice$1 = uncurryThis$b([].splice);
var id = 0;
var uncaughtFrozenStore = function(state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
  this.entries = [];
};
var findUncaughtFrozen = function(store, key) {
  return find(store.entries, function(it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  "delete": function(key) {
    var index = findIndex(this.entries, function(it) {
      return it[0] === key;
    });
    if (~index) splice$1(this.entries, index, 1);
    return !!~index;
  }
};
var collectionWeak$1 = {
  getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function(that, iterable) {
      anInstance$1(that, Prototype);
      setInternalState$1(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: void 0
      });
      if (!isNullOrUndefined$2(iterable)) iterate$1(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor$1(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var data2 = getWeakData(anObject$4(key), true);
      if (data2 === true) uncaughtFrozenStore(state).set(key, value);
      else data2[state.id] = value;
      return that;
    };
    defineBuiltIns$1(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      "delete": function(key) {
        var state = getInternalState2(this);
        if (!isObject$4(key)) return false;
        var data2 = getWeakData(key);
        if (data2 === true) return uncaughtFrozenStore(state)["delete"](key);
        return data2 && hasOwn2(data2, state.id) && delete data2[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has2(key) {
        var state = getInternalState2(this);
        if (!isObject$4(key)) return false;
        var data2 = getWeakData(key);
        if (data2 === true) return uncaughtFrozenStore(state).has(key);
        return data2 && hasOwn2(data2, state.id);
      }
    });
    defineBuiltIns$1(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get2(key) {
        var state = getInternalState2(this);
        if (isObject$4(key)) {
          var data2 = getWeakData(key);
          if (data2 === true) return uncaughtFrozenStore(state).get(key);
          return data2 ? data2[state.id] : void 0;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set2(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return Constructor;
  }
};
var collection$2 = collection$3;
var collectionWeak = collectionWeak$1;
collection$2("WeakSet", function(init) {
  return function WeakSet2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionWeak);
var ScrollDirection;
(function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["SCROLL_NONE"] = 0] = "SCROLL_NONE";
  ScrollDirection2[ScrollDirection2["SCROLL_BACKWARD"] = 1] = "SCROLL_BACKWARD";
  ScrollDirection2[ScrollDirection2["SCROLL_FORWARD"] = 2] = "SCROLL_FORWARD";
})(ScrollDirection || (ScrollDirection = {}));
var Position;
(function(Position2) {
  Position2[Position2["TOP"] = 0] = "TOP";
  Position2[Position2["RIGHT"] = 1] = "RIGHT";
  Position2[Position2["BOTTOM"] = 2] = "BOTTOM";
  Position2[Position2["LEFT"] = 3] = "LEFT";
})(Position || (Position = {}));
var OPTIONS_DEFAULT_DOMAIN_TYPE = "hour";
var OPTIONS_DEFAULT_SUBDOMAIN_TYPE = "minute";
var OPTIONS_DEFAULT_SUBDOMAIN_WIDTH = 10;
var OPTIONS_DEFAULT_SUBDOMAIN_HEIGHT = 10;
var OPTIONS_DEFAULT_SUBDOMAIN_GUTTER = 2;
var OPTIONS_DEFAULT_SUBDOMAIN_RADIUS = 0;
var OPTIONS_DEFAULT_ANIMATION_DURATION = 200;
var OPTIONS_DEFAULT_RANGE = 12;
var OPTIONS_DEFAULT_ITEM_SELECTOR = "#cal-heatmap";
var OPTIONS_DEFAULT_THEME = "light";
var OPTIONS_DEFAULT_LOCALE = "en";
var SCALE_BASE_OPACITY_COLOR = "red";
var SCALE_BASE_COLOR_SCHEME = "YlOrBr";
var SCALE_BASE_COLOR_TYPE = "quantize";
var SCALE_BASE_COLOR_DOMAIN = [0, 100];
var _Navigator_instances;
var _Navigator_isDomainBoundaryReached;
var _Navigator_setDomainsBoundaryReached;
var Navigator = function() {
  function Navigator2(calendar) {
    _classCallCheck(this, Navigator2);
    _Navigator_instances.add(this);
    this.calendar = calendar;
    this.maxDomainReached = false;
    this.minDomainReached = false;
  }
  _createClass(Navigator2, [{
    key: "loadNewDomains",
    value: function loadNewDomains(newDomainCollection) {
      var _this = this;
      var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ScrollDirection.SCROLL_NONE;
      var options = this.calendar.options.options;
      var templatesClt = this.calendar.templateCollection;
      var minDate = options.date.min ? templatesClt.get(options.domain.type).extractUnit(+options.date.min) : void 0;
      var maxDate = options.date.max ? templatesClt.get(options.domain.type).extractUnit(+options.date.max) : void 0;
      var domainCollection = this.calendar.domainCollection;
      if (__classPrivateFieldGet(this, _Navigator_instances, "m", _Navigator_isDomainBoundaryReached).call(this, newDomainCollection, minDate, maxDate, direction)) {
        return ScrollDirection.SCROLL_NONE;
      }
      if (direction !== ScrollDirection.SCROLL_NONE) {
        newDomainCollection.clamp(minDate, maxDate).slice(options.range, direction === ScrollDirection.SCROLL_FORWARD);
      }
      domainCollection.merge(newDomainCollection, options.range, function(domainKey, index) {
        var subDomainEndDate = null;
        if (newDomainCollection.at(index + 1)) {
          subDomainEndDate = newDomainCollection.at(index + 1);
        } else {
          subDomainEndDate = _this.calendar.dateHelper.intervals(options.domain.type, domainKey, 2).pop();
        }
        return templatesClt.get(options.subDomain.type).mapping(domainKey, subDomainEndDate).map(function(d) {
          return Object.assign(Object.assign({}, d), {
            v: options.data.defaultValue
          });
        });
      });
      __classPrivateFieldGet(this, _Navigator_instances, "m", _Navigator_setDomainsBoundaryReached).call(this, domainCollection.min, domainCollection.max, minDate, maxDate);
      if (direction === ScrollDirection.SCROLL_BACKWARD) {
        this.calendar.eventEmitter.emit("domainsLoaded", [domainCollection.min]);
      } else if (direction === ScrollDirection.SCROLL_FORWARD) {
        this.calendar.eventEmitter.emit("domainsLoaded", [domainCollection.max]);
      }
      return direction;
    }
  }, {
    key: "jumpTo",
    value: function jumpTo(date, reset) {
      var _this$calendar = this.calendar, domainCollection = _this$calendar.domainCollection, options = _this$calendar.options;
      var minDate = new Date(domainCollection.min);
      var maxDate = new Date(domainCollection.max);
      if (date < minDate) {
        return this.loadNewDomains(this.calendar.createDomainCollection(date, minDate, false), ScrollDirection.SCROLL_BACKWARD);
      }
      if (reset) {
        return this.loadNewDomains(this.calendar.createDomainCollection(date, options.options.range), minDate < date ? ScrollDirection.SCROLL_FORWARD : ScrollDirection.SCROLL_BACKWARD);
      }
      if (date > maxDate) {
        return this.loadNewDomains(this.calendar.createDomainCollection(maxDate, date, false), ScrollDirection.SCROLL_FORWARD);
      }
      return ScrollDirection.SCROLL_NONE;
    }
  }]);
  return Navigator2;
}();
_Navigator_instances = /* @__PURE__ */ new WeakSet(), _Navigator_isDomainBoundaryReached = function _Navigator_isDomainBoundaryReached2(newDomainCollection, minDate, maxDate, direction) {
  if (maxDate && newDomainCollection.max >= maxDate && this.maxDomainReached && direction === ScrollDirection.SCROLL_FORWARD) {
    return true;
  }
  if (minDate && newDomainCollection.min <= minDate && this.minDomainReached && direction === ScrollDirection.SCROLL_BACKWARD) {
    return true;
  }
  return false;
}, _Navigator_setDomainsBoundaryReached = function _Navigator_setDomainsBoundaryReached2(lowerBound, upperBound, min3, max3) {
  if (min3) {
    var reached = lowerBound <= min3;
    this.calendar.eventEmitter.emit(reached ? "minDateReached" : "minDateNotReached");
    this.minDomainReached = reached;
  }
  if (max3) {
    var _reached = upperBound >= max3;
    this.calendar.eventEmitter.emit(_reached ? "maxDateReached" : "maxDateNotReached");
    this.maxDomainReached = _reached;
  }
};
var $TypeError$3 = TypeError;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var doesNotExceedSafeInteger$1 = function(it) {
  if (it > MAX_SAFE_INTEGER$2) throw $TypeError$3("Maximum allowed index exceeded");
  return it;
};
var $$b = _export;
var fails$b = fails$u;
var isArray2 = isArray$5;
var isObject$3 = isObject$j;
var toObject$4 = toObject$a;
var lengthOfArrayLike$2 = lengthOfArrayLike$9;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
var createProperty$1 = createProperty$4;
var arraySpeciesCreate = arraySpeciesCreate$2;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$4;
var wellKnownSymbol$4 = wellKnownSymbol$m;
var V8_VERSION = engineV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$4("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$b(function() {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var isConcatSpreadable = function(O) {
  if (!isObject$3(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray2(O);
};
var FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$1("concat");
$$b({ target: "Array", proto: true, arity: 1, forced: FORCED$2 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject$4(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length2, len, E;
    for (i = -1, length2 = arguments.length; i < length2; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike$2(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty$1(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty$1(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});
var fails$a = fails$u;
var arrayMethodIsStrict$3 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$a(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var $$a = _export;
var uncurryThis$a = functionUncurryThis;
var IndexedObject = indexedObject;
var toIndexedObject$1 = toIndexedObject$9;
var arrayMethodIsStrict$2 = arrayMethodIsStrict$3;
var nativeJoin = uncurryThis$a([].join);
var ES3_STRINGS = IndexedObject !== Object;
var FORCED$1 = ES3_STRINGS || !arrayMethodIsStrict$2("join", ",");
$$a({ target: "Array", proto: true, forced: FORCED$1 }, {
  join: function join2(separator) {
    return nativeJoin(toIndexedObject$1(this), separator === void 0 ? "," : separator);
  }
});
var create$1 = objectCreate$1;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$3;
var defineBuiltIns = defineBuiltIns$2;
var bind$1 = functionBindContext;
var anInstance = anInstance$4;
var isNullOrUndefined$1 = isNullOrUndefined$8;
var iterate = iterate$6;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$3;
var setSpecies = setSpecies$2;
var DESCRIPTORS$2 = descriptors;
var fastKey = internalMetadataExports.fastKey;
var InternalStateModule = internalState;
var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var collectionStrong$2 = {
  getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function(that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create$1(null),
        first: void 0,
        last: void 0,
        size: 0
      });
      if (!DESCRIPTORS$2) that.size = 0;
      if (!isNullOrUndefined$1(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
    });
    var Prototype = Constructor.prototype;
    var getInternalState2 = internalStateGetterFor(CONSTRUCTOR_NAME);
    var define = function(that, key, value) {
      var state = getInternalState2(that);
      var entry = getEntry(that, key);
      var previous, index;
      if (entry) {
        entry.value = value;
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key,
          value,
          previous: previous = state.last,
          next: void 0,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS$2) state.size++;
        else that.size++;
        if (index !== "F") state.index[index] = entry;
      }
      return that;
    };
    var getEntry = function(that, key) {
      var state = getInternalState2(that);
      var index = fastKey(key);
      var entry;
      if (index !== "F") return state.index[index];
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key === key) return entry;
      }
    };
    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear2() {
        var that = this;
        var state = getInternalState2(that);
        var data2 = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = void 0;
          delete data2[entry.index];
          entry = entry.next;
        }
        state.first = state.last = void 0;
        if (DESCRIPTORS$2) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      "delete": function(key) {
        var that = this;
        var state = getInternalState2(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next2 = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next2;
          if (next2) next2.previous = prev;
          if (state.first === entry) state.first = next2;
          if (state.last === entry) state.last = prev;
          if (DESCRIPTORS$2) state.size--;
          else that.size--;
        }
        return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach3(callbackfn) {
        var state = getInternalState2(this);
        var boundFunction = bind$1(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has2(key) {
        return !!getEntry(this, key);
      }
    });
    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get2(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set2(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS$2) defineBuiltInAccessor$1(Prototype, "size", {
      configurable: true,
      get: function() {
        return getInternalState2(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind,
        last: void 0
      });
    }, function() {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      while (entry && entry.removed) entry = entry.previous;
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      if (kind === "keys") return createIterResultObject(entry.key, false);
      if (kind === "values") return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
    setSpecies(CONSTRUCTOR_NAME);
  }
};
var collection$1 = collection$3;
var collectionStrong$1 = collectionStrong$2;
collection$1("Map", function(init) {
  return function Map2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong$1);
var tryToString = tryToString$5;
var $TypeError$2 = TypeError;
var deletePropertyOrThrow$1 = function(O, P) {
  if (!delete O[P]) throw new $TypeError$2("Cannot delete property " + tryToString(P) + " of " + tryToString(O));
};
var arraySlice = arraySliceSimple;
var floor$1 = Math.floor;
var mergeSort = function(array, comparefn) {
  var length2 = array.length;
  var middle = floor$1(length2 / 2);
  return length2 < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};
var insertionSort = function(array, comparefn) {
  var length2 = array.length;
  var i = 1;
  var element, j;
  while (i < length2) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  }
  return array;
};
var merge = function(array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
  }
  return array;
};
var arraySort = mergeSort;
var userAgent$1 = engineUserAgent;
var firefox = userAgent$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];
var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent = engineUserAgent;
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];
var $$9 = _export;
var uncurryThis$9 = functionUncurryThis;
var aCallable = aCallable$a;
var toObject$3 = toObject$a;
var lengthOfArrayLike$1 = lengthOfArrayLike$9;
var deletePropertyOrThrow = deletePropertyOrThrow$1;
var toString$6 = toString$9;
var fails$9 = fails$u;
var internalSort = arraySort;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$3;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var nativeSort = uncurryThis$9(test.sort);
var push$2 = uncurryThis$9(test.push);
var FAILS_ON_UNDEFINED = fails$9(function() {
  test.sort(void 0);
});
var FAILS_ON_NULL = fails$9(function() {
  test.sort(null);
});
var STRICT_METHOD$1 = arrayMethodIsStrict$1("sort");
var STABLE_SORT = !fails$9(function() {
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;
  var result = "";
  var code, chr, value, index;
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);
    switch (code) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }
  test.sort(function(a, b) {
    return b.v - a.v;
  });
  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;
var getSortCompare = function(comparefn) {
  return function(x, y) {
    if (y === void 0) return -1;
    if (x === void 0) return 1;
    if (comparefn !== void 0) return +comparefn(x, y) || 0;
    return toString$6(x) > toString$6(y) ? 1 : -1;
  };
};
$$9({ target: "Array", proto: true, forced: FORCED }, {
  sort: function sort2(comparefn) {
    if (comparefn !== void 0) aCallable(comparefn);
    var array = toObject$3(this);
    if (STABLE_SORT) return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike$1(array);
    var itemsLength, index;
    for (index = 0; index < arrayLength; index++) {
      if (index in array) push$2(items, array[index]);
    }
    internalSort(items, getSortCompare(comparefn));
    itemsLength = lengthOfArrayLike$1(items);
    index = 0;
    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);
    return array;
  }
});
var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict = arrayMethodIsStrict$3;
var STRICT_METHOD = arrayMethodIsStrict("forEach");
var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var global$4 = global$n;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var forEach2 = arrayForEach;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$6;
var handlePrototype = function(CollectionPrototype) {
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach2) try {
    createNonEnumerableProperty$1(CollectionPrototype, "forEach", forEach2);
  } catch (error) {
    CollectionPrototype.forEach = forEach2;
  }
};
for (COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(global$4[COLLECTION_NAME] && global$4[COLLECTION_NAME].prototype);
  }
}
var COLLECTION_NAME;
handlePrototype(DOMTokenListPrototype);
function isVertical(position2) {
  return position2 === "top" || position2 === "bottom";
}
function horizontalPadding(padding) {
  return padding[Position.LEFT] + padding[Position.RIGHT];
}
function verticalPadding(padding) {
  return padding[Position.TOP] + padding[Position.BOTTOM];
}
var _DomainCoordinates_instances;
var _DomainCoordinates_getWidth;
var _DomainCoordinates_getHeight;
var DomainCoordinates = function() {
  function DomainCoordinates2(calendar, domainPainter) {
    _classCallCheck(this, DomainCoordinates2);
    _DomainCoordinates_instances.add(this);
    this.calendar = calendar;
    this.domainPainter = domainPainter;
    this.collection = /* @__PURE__ */ new Map();
    this.scrollDirection = ScrollDirection.SCROLL_FORWARD;
  }
  _createClass(DomainCoordinates2, [{
    key: "get",
    value: function get2(domainKey) {
      return this.collection.get(domainKey);
    }
  }, {
    key: "update",
    value: function update(collection2, scrollDirection) {
      var _this = this;
      var _this$calendar$option = this.calendar.options.options, verticalOrientation = _this$calendar$option.verticalOrientation, domain = _this$calendar$option.domain;
      this.scrollDirection = scrollDirection;
      var dimensions = {
        width: 0,
        height: 0
      };
      var exitingTotal = 0;
      var scrollFactor = scrollDirection === ScrollDirection.SCROLL_FORWARD ? -1 : 1;
      var keys4 = collection2.keys;
      if (this.calendar.options.options.domain.sort === "desc") {
        keys4.reverse();
        scrollFactor *= -1;
      }
      collection2.yankedDomains.forEach(function(domainKey) {
        exitingTotal += _this.collection.get(domainKey)[verticalOrientation ? "height" : "width"];
      });
      collection2.yankedDomains.forEach(function(domainKey) {
        var coor = _this.collection.get(domainKey);
        _this.collection.set(domainKey, Object.assign(Object.assign({}, coor), {
          x: verticalOrientation ? coor.x : coor.x + exitingTotal * scrollFactor,
          y: verticalOrientation ? coor.y + exitingTotal * scrollFactor : coor.y
        }));
      });
      keys4.forEach(function(domainKey) {
        var w = __classPrivateFieldGet(_this, _DomainCoordinates_instances, "m", _DomainCoordinates_getWidth).call(_this, domainKey);
        var h = __classPrivateFieldGet(_this, _DomainCoordinates_instances, "m", _DomainCoordinates_getHeight).call(_this, domainKey);
        if (verticalOrientation) {
          dimensions.height += h;
          dimensions.width = Math.max(w, dimensions.width);
        } else {
          dimensions.width += w;
          dimensions.height = Math.max(h, dimensions.height);
        }
        var x = dimensions.width - w;
        var y = dimensions.height - h;
        _this.collection.set(domainKey, Object.assign(Object.assign({}, _this.collection.get(domainKey)), {
          x: verticalOrientation ? 0 : x,
          y: verticalOrientation ? y : 0,
          pre_x: verticalOrientation ? x : x - exitingTotal * scrollFactor,
          pre_y: verticalOrientation ? y - exitingTotal * scrollFactor : y,
          width: w,
          height: h,
          inner_width: w - (verticalOrientation ? 0 : domain.gutter),
          inner_height: h - (!verticalOrientation ? 0 : domain.gutter)
        }));
      });
      return dimensions;
    }
  }]);
  return DomainCoordinates2;
}();
_DomainCoordinates_instances = /* @__PURE__ */ new WeakSet(), _DomainCoordinates_getWidth = function _DomainCoordinates_getWidth2(d) {
  var _this$calendar$option2 = this.calendar.options.options, domain = _this$calendar$option2.domain, subDomain = _this$calendar$option2.subDomain, x = _this$calendar$option2.x, verticalOrientation = _this$calendar$option2.verticalOrientation;
  var columnsCount = this.calendar.templateCollection.get(subDomain.type).columnsCount(d);
  var subDomainWidth = (subDomain.width + subDomain.gutter) * columnsCount - subDomain.gutter;
  return horizontalPadding(domain.padding) + x.domainHorizontalLabelWidth + (verticalOrientation ? 0 : domain.gutter) + subDomainWidth;
}, _DomainCoordinates_getHeight = function _DomainCoordinates_getHeight2(d) {
  var _this$calendar$option3 = this.calendar.options.options, domain = _this$calendar$option3.domain, subDomain = _this$calendar$option3.subDomain, x = _this$calendar$option3.x, verticalOrientation = _this$calendar$option3.verticalOrientation;
  var rowsCount = this.calendar.templateCollection.get(subDomain.type).rowsCount(d);
  var subDomainHeight = (subDomain.height + subDomain.gutter) * rowsCount - subDomain.gutter;
  return verticalPadding(domain.padding) + subDomainHeight + (verticalOrientation ? domain.gutter : 0) + x.domainVerticalLabelHeight;
};
var _DomainPainter_instances;
var _DomainPainter_getClassName;
var DEFAULT_SELECTOR$3 = ".ch-domain";
var DomainPainter = function() {
  function DomainPainter2(calendar) {
    _classCallCheck(this, DomainPainter2);
    _DomainPainter_instances.add(this);
    this.calendar = calendar;
    this.coordinates = new DomainCoordinates(calendar, this);
    this.root = null;
    this.dimensions = {
      width: 0,
      height: 0
    };
  }
  _createClass(DomainPainter2, [{
    key: "paint",
    value: function paint(scrollDirection, rootNode) {
      var _this = this;
      var animationDuration = this.calendar.options.options.animationDuration;
      var t = rootNode.transition().duration(animationDuration);
      var coor = this.coordinates;
      this.dimensions = coor.update(this.calendar.domainCollection, scrollDirection);
      var promises = [];
      this.root = rootNode.selectAll(DEFAULT_SELECTOR$3).data(this.calendar.domainCollection.keys, function(d) {
        return d;
      }).join(function(enter) {
        return enter.append("svg").attr("x", function(d) {
          return coor.get(d).pre_x;
        }).attr("y", function(d) {
          return coor.get(d).pre_y;
        }).attr("width", function(d) {
          return coor.get(d).inner_width;
        }).attr("height", function(d) {
          return coor.get(d).inner_height;
        }).attr("class", function(d) {
          return __classPrivateFieldGet(_this, _DomainPainter_instances, "m", _DomainPainter_getClassName).call(_this, d);
        }).call(function(enterSelection) {
          return enterSelection.append("rect").attr("width", function(d) {
            return coor.get(d).inner_width;
          }).attr("height", function(d) {
            return coor.get(d).inner_height;
          }).attr("class", "".concat(DEFAULT_SELECTOR$3.slice(1), "-bg"));
        }).call(function(enterSelection) {
          return promises.push(enterSelection.transition(t).attr("x", function(d) {
            return coor.get(d).x;
          }).attr("y", function(d) {
            return coor.get(d).y;
          }).end());
        });
      }, function(update) {
        return update.call(function(updateSelection) {
          return promises.push(updateSelection.transition(t).attr("x", function(d) {
            return coor.get(d).x;
          }).attr("y", function(d) {
            return coor.get(d).y;
          }).attr("width", function(d) {
            return coor.get(d).inner_width;
          }).attr("height", function(d) {
            return coor.get(d).inner_height;
          }).end());
        }).call(function(updateSelection) {
          return promises.push(updateSelection.selectAll("".concat(DEFAULT_SELECTOR$3, "-bg")).transition(t).attr("width", function(d) {
            return coor.get(d).inner_width;
          }).attr("height", function(d) {
            return coor.get(d).inner_height;
          }).end());
        });
      }, function(exit) {
        return exit.call(function(exitSelection) {
          return promises.push(exitSelection.transition(t).attr("x", function(d) {
            return coor.get(d).x;
          }).attr("y", function(d) {
            return coor.get(d).y;
          }).remove().end());
        });
      });
      return promises;
    }
  }]);
  return DomainPainter2;
}();
_DomainPainter_instances = /* @__PURE__ */ new WeakSet(), _DomainPainter_getClassName = function _DomainPainter_getClassName2(d) {
  var classname = DEFAULT_SELECTOR$3.slice(1);
  var helper = this.calendar.dateHelper.date(d);
  switch (this.calendar.options.options.domain.type) {
    case "hour":
      classname += " h_".concat(helper.hour());
      break;
    case "day":
      classname += " d_".concat(helper.date(), " dy_").concat(helper.format("d") + 1);
      break;
    case "week":
      classname += " w_".concat(helper.week());
      break;
    case "month":
      classname += " m_".concat(helper.month() + 1);
      break;
    case "year":
      classname += " y_".concat(helper.year());
      break;
  }
  return classname;
};
var $$8 = _export;
var $includes = arrayIncludes.includes;
var fails$8 = fails$u;
var addToUnscopables = addToUnscopables$3;
var BROKEN_ON_SPARSE = fails$8(function() {
  return !Array(1).includes();
});
$$8({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables("includes");
var $$7 = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$4;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
$$7({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var anObject$3 = anObject$f;
var iteratorClose = iteratorClose$2;
var callWithSafeIterationClosing$1 = function(iterator, fn, value, ENTRIES2) {
  try {
    return ENTRIES2 ? fn(anObject$3(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, "throw", error);
  }
};
var bind = functionBindContext;
var call$3 = functionCall;
var toObject$2 = toObject$a;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var isConstructor3 = isConstructor$4;
var lengthOfArrayLike = lengthOfArrayLike$9;
var createProperty = createProperty$4;
var getIterator = getIterator$2;
var getIteratorMethod = getIteratorMethod$3;
var $Array = Array;
var arrayFrom = function from(arrayLike) {
  var O = toObject$2(arrayLike);
  var IS_CONSTRUCTOR = isConstructor3(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
  var mapping = mapfn !== void 0;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length2, result, step, iterator, next2, value;
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next2 = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (; !(step = call$3(next2, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length2 = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length2) : $Array(length2);
    for (; length2 > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};
var $$6 = _export;
var from2 = arrayFrom;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$3;
var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
  Array.from(iterable);
});
$$6({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
  from: from2
});
var _DomainCollection_instances;
var _DomainCollection_setSubDomainValues;
var _DomainCollection_extractValues;
var _DomainCollection_refreshKeys;
var DOMAIN_FORMAT = {
  year: "YYYY",
  month: "MMMM",
  week: "wo [week] YYYY",
  xDay: "Do MMM",
  ghDay: "Do MMM",
  day: "Do MMM",
  hour: "HH:00",
  minute: "HH:mm"
};
var DomainCollection = function() {
  function DomainCollection2(dateHelper, interval, start, range3) {
    var excludeEnd = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    _classCallCheck(this, DomainCollection2);
    _DomainCollection_instances.add(this);
    this.collection = /* @__PURE__ */ new Map();
    this.dateHelper = dateHelper;
    if (interval && start && range3) {
      var ts = this.dateHelper.intervals(interval, start, range3, excludeEnd).map(function(d) {
        return castArray(d);
      });
      this.collection = new Map(ts);
    }
    this.min = 0;
    this.max = 0;
    this.keys = [];
    this.yankedDomains = [];
    if (this.collection.size > 0) {
      __classPrivateFieldGet(this, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(this);
    }
  }
  _createClass(DomainCollection2, [{
    key: "has",
    value: function has2(key) {
      return this.collection.has(key);
    }
  }, {
    key: "get",
    value: function get2(key) {
      return this.collection.get(key);
    }
  }, {
    key: "forEach",
    value: function forEach3(callback) {
      return this.collection.forEach(callback);
    }
  }, {
    key: "at",
    value: function at(index) {
      return this.keys[index];
    }
  }, {
    key: "clamp",
    value: function clamp(minDate, maxDate) {
      var _this = this;
      if (minDate && this.min < minDate) {
        this.keys.filter(function(key) {
          return key < minDate;
        }).forEach(function(d) {
          return _this.collection.delete(d);
        });
      }
      if (maxDate && this.max > maxDate) {
        this.keys.filter(function(key) {
          return key > maxDate;
        }).forEach(function(d) {
          return _this.collection.delete(d);
        });
      }
      __classPrivateFieldGet(this, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(this);
      return this;
    }
  }, {
    key: "merge",
    value: function merge2(newCollection, limit, createValueCallback) {
      var _this2 = this;
      this.yankedDomains = [];
      newCollection.keys.forEach(function(domainKey, index) {
        if (_this2.has(domainKey)) {
          return;
        }
        if (_this2.collection.size >= limit) {
          var keyToRemove = _this2.max;
          if (domainKey > _this2.max) {
            keyToRemove = _this2.min;
          }
          if (keyToRemove && _this2.collection.delete(keyToRemove)) {
            _this2.yankedDomains.push(keyToRemove);
          }
        }
        _this2.collection.set(domainKey, createValueCallback(domainKey, index));
        __classPrivateFieldGet(_this2, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(_this2);
      });
      this.yankedDomains = this.yankedDomains.sort(function(a, b) {
        return a - b;
      });
    }
  }, {
    key: "slice",
    value: function slice3() {
      var _this3 = this;
      var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var fromBeginning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (this.keys.length > limit) {
        var keysToDelete = fromBeginning ? this.keys.slice(0, -limit) : this.keys.slice(limit);
        keysToDelete.forEach(function(key) {
          _this3.collection.delete(key);
        });
        __classPrivateFieldGet(this, _DomainCollection_instances, "m", _DomainCollection_refreshKeys).call(this);
      }
      return this;
    }
  }, {
    key: "fill",
    value: function fill3(data2, _ref, subDomainKeyExtractor) {
      var _this4 = this;
      var x = _ref.x, y = _ref.y, groupY = _ref.groupY, defaultValue = _ref.defaultValue;
      var groupedRecords = this.groupRecords(data2, x, subDomainKeyExtractor);
      this.keys.forEach(function(domainKey) {
        var records = groupedRecords.get(domainKey) || {};
        __classPrivateFieldGet(_this4, _DomainCollection_instances, "m", _DomainCollection_setSubDomainValues).call(_this4, domainKey, records, y, groupY, defaultValue);
      });
    }
  }, {
    key: "groupRecords",
    value: function groupRecords(data2, x, subDomainKeyExtractor) {
      var _this5 = this;
      var results = /* @__PURE__ */ new Map();
      var validSubDomainTimestamp = /* @__PURE__ */ new Map();
      this.keys.forEach(function(domainKey) {
        _this5.get(domainKey).forEach(function(subDomain) {
          validSubDomainTimestamp.set(subDomain.t, domainKey);
        });
      });
      data2.forEach(function(d) {
        var timestamp = _this5.extractTimestamp(d, x, subDomainKeyExtractor);
        if (validSubDomainTimestamp.has(timestamp)) {
          var domainKey = validSubDomainTimestamp.get(timestamp);
          var records = results.get(domainKey) || {};
          records[timestamp] || (records[timestamp] = []);
          records[timestamp].push(d);
          results.set(domainKey, records);
        }
      });
      return results;
    }
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "groupValues",
    value: function groupValues(values2, groupFn) {
      var cleanedValues = values2.filter(function(n) {
        return n !== null;
      });
      if (typeof groupFn === "string") {
        if (cleanedValues.every(function(n) {
          return typeof n === "number";
        })) {
          switch (groupFn) {
            case "sum":
              return cleanedValues.reduce(function(a, b) {
                return a + b;
              }, 0);
            case "count":
              return cleanedValues.length;
            case "min":
              return Math.min.apply(Math, _toConsumableArray(cleanedValues)) || null;
            case "max":
              return Math.max.apply(Math, _toConsumableArray(cleanedValues)) || null;
            case "average":
              return cleanedValues.length > 0 ? cleanedValues.reduce(function(a, b) {
                return a + b;
              }, 0) / cleanedValues.length : null;
            default:
              return null;
          }
        }
        switch (groupFn) {
          case "count":
            return cleanedValues.length;
          default:
            return null;
        }
      } else if (typeof groupFn === "function") {
        return groupFn(cleanedValues);
      }
      return null;
    }
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "extractTimestamp",
    value: function extractTimestamp(datum, x, extractorFn) {
      var timestamp = typeof x === "function" ? x(datum) : datum[x];
      if (typeof timestamp === "string") {
        timestamp = +new Date(timestamp);
      }
      return extractorFn(timestamp);
    }
  }]);
  return DomainCollection2;
}();
_DomainCollection_instances = /* @__PURE__ */ new WeakSet(), _DomainCollection_setSubDomainValues = function _DomainCollection_setSubDomainValues2(domainKey, records, y, groupY, defaultValue) {
  var _this6 = this;
  this.get(domainKey).forEach(function(subDomain, index) {
    var value = defaultValue;
    if (records.hasOwnProperty(subDomain.t)) {
      value = _this6.groupValues(__classPrivateFieldGet(_this6, _DomainCollection_instances, "m", _DomainCollection_extractValues).call(_this6, records[subDomain.t], y), groupY);
    }
    _this6.get(domainKey)[index].v = value;
  });
}, _DomainCollection_extractValues = function _DomainCollection_extractValues2(data2, y) {
  return data2.map(function(d) {
    return typeof y === "function" ? y(d) : d[y];
  });
}, _DomainCollection_refreshKeys = function _DomainCollection_refreshKeys2() {
  this.keys = Array.from(this.collection.keys()).map(function(d) {
    return parseInt(d, 10);
  }).sort(function(a, b) {
    return a - b;
  });
  var keys4 = this.keys;
  this.min = keys4[0];
  this.max = keys4[keys4.length - 1];
  return this.keys;
};
var _DomainLabelPainter_instances;
var _DomainLabelPainter_textVerticalAlign;
var _DomainLabelPainter_getX;
var _DomainLabelPainter_getY;
var _DomainLabelPainter_getDomainInsideWidth;
var _DomainLabelPainter_getDomainInsideHeight;
var _DomainLabelPainter_domainRotate;
var DEFAULT_SELECTOR$2 = ".ch-domain-text";
var DomainLabelPainter = function() {
  function DomainLabelPainter2(calendar) {
    _classCallCheck(this, DomainLabelPainter2);
    _DomainLabelPainter_instances.add(this);
    this.calendar = calendar;
  }
  _createClass(DomainLabelPainter2, [{
    key: "paint",
    value: function paint(root2) {
      var _this = this;
      var _this$calendar$option = this.calendar.options.options.domain, label = _this$calendar$option.label, type = _this$calendar$option.type;
      var dateHelper = this.calendar.dateHelper;
      var format = label.text;
      if (format === null || format === "") {
        return;
      }
      if (typeof format === "undefined") {
        format = DOMAIN_FORMAT[type];
      }
      root2.selectAll(DEFAULT_SELECTOR$2).data(function(d) {
        return [d];
      }, function(d) {
        return d;
      }).join(function(enter) {
        return enter.append("text").attr("class", DEFAULT_SELECTOR$2.slice(1)).attr("x", function(d) {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getX).call(_this, d);
        }).attr("y", function(d) {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getY).call(_this, d);
        }).attr("text-anchor", label.textAlign).attr("dominant-baseline", function() {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_textVerticalAlign).call(_this);
        }).text(function(d, i, nodes) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            dateHelper.format(d, format, nodes[i])
          );
        }).call(function(selection) {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_domainRotate).call(_this, selection);
        });
      }, function(update) {
        update.attr("x", function(d) {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getX).call(_this, d);
        }).attr("y", function(d) {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getY).call(_this, d);
        }).attr("text-anchor", label.textAlign).attr("dominant-baseline", function() {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_textVerticalAlign).call(_this);
        }).text(function(d, i, nodes) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            dateHelper.format(d, format, nodes[i])
          );
        }).call(function(selection) {
          return __classPrivateFieldGet(_this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_domainRotate).call(_this, selection);
        });
      });
    }
  }]);
  return DomainLabelPainter2;
}();
_DomainLabelPainter_instances = /* @__PURE__ */ new WeakSet(), _DomainLabelPainter_textVerticalAlign = function _DomainLabelPainter_textVerticalAlign2() {
  var _this$calendar$option2 = this.calendar.options.options.domain.label, position2 = _this$calendar$option2.position, rotate = _this$calendar$option2.rotate;
  if (isVertical(position2)) {
    return "middle";
  }
  if (rotate === "left" && position2 === "left" || rotate === "right" && position2 === "right") {
    return "bottom";
  }
  return "hanging";
}, _DomainLabelPainter_getX = function _DomainLabelPainter_getX2(d) {
  var _this$calendar$option3 = this.calendar.options.options.domain, padding = _this$calendar$option3.padding, _this$calendar$option4 = _this$calendar$option3.label, position2 = _this$calendar$option4.position, textAlign = _this$calendar$option4.textAlign, offset = _this$calendar$option4.offset;
  var domainHorizontalLabelWidth = this.calendar.options.options.x.domainHorizontalLabelWidth;
  var x = padding[Position.LEFT];
  if (position2 === "right") {
    x += __classPrivateFieldGet(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(this, d);
  }
  if (textAlign === "middle") {
    if (["top", "bottom"].includes(position2)) {
      x += __classPrivateFieldGet(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(this, d) / 2;
    } else {
      x += domainHorizontalLabelWidth / 2;
    }
  }
  if (textAlign === "end") {
    if (isVertical(position2)) {
      x += __classPrivateFieldGet(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(this, d);
    } else {
      x += domainHorizontalLabelWidth;
    }
  }
  return x + offset.x;
}, _DomainLabelPainter_getY = function _DomainLabelPainter_getY2(d) {
  var _this$calendar$option5 = this.calendar.options.options, _this$calendar$option6 = _this$calendar$option5.domain, _this$calendar$option7 = _this$calendar$option6.label, position2 = _this$calendar$option7.position, offset = _this$calendar$option7.offset, padding = _this$calendar$option6.padding, x = _this$calendar$option5.x;
  var y = padding[Position.TOP] + x.domainVerticalLabelHeight / 2;
  if (position2 === "bottom") {
    y += __classPrivateFieldGet(this, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideHeight).call(this, d);
  }
  return y + offset.y;
}, _DomainLabelPainter_getDomainInsideWidth = function _DomainLabelPainter_getDomainInsideWidth2(d) {
  var _this$calendar$option8 = this.calendar.options.options, padding = _this$calendar$option8.domain.padding, domainHorizontalLabelWidth = _this$calendar$option8.x.domainHorizontalLabelWidth;
  var coordinates = this.calendar.calendarPainter.domainsContainerPainter.domainPainter.coordinates;
  return coordinates.get(d).inner_width - domainHorizontalLabelWidth - horizontalPadding(padding);
}, _DomainLabelPainter_getDomainInsideHeight = function _DomainLabelPainter_getDomainInsideHeight2(d) {
  var _this$calendar$option9 = this.calendar.options.options, domainVerticalLabelHeight = _this$calendar$option9.x.domainVerticalLabelHeight, padding = _this$calendar$option9.domain.padding;
  var coordinates = this.calendar.calendarPainter.domainsContainerPainter.domainPainter.coordinates;
  return coordinates.get(d).inner_height - domainVerticalLabelHeight - verticalPadding(padding);
}, _DomainLabelPainter_domainRotate = function _DomainLabelPainter_domainRotate2(selection) {
  var _this2 = this;
  var _this$calendar$option10 = this.calendar.options.options, _this$calendar$option11 = _this$calendar$option10.domain.label, rotate = _this$calendar$option11.rotate, textAlign = _this$calendar$option11.textAlign, position2 = _this$calendar$option11.position, x = _this$calendar$option10.x;
  var labelWidth = x.domainHorizontalLabelWidth;
  switch (rotate) {
    case "right":
      selection.attr("transform", function(d) {
        var domainWidth = __classPrivateFieldGet(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(_this2, d);
        var domainHeight = __classPrivateFieldGet(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideHeight).call(_this2, d);
        var s = ["rotate(90, ".concat(position2 === "right" ? domainWidth : labelWidth, ", 0)")];
        switch (position2) {
          case "right":
            if (textAlign === "middle") {
              s.push("translate(".concat(domainHeight / 2 - labelWidth / 2, ")"));
            } else if (textAlign === "end") {
              s.push("translate(".concat(domainHeight - labelWidth, ")"));
            }
            break;
          case "left":
            if (textAlign === "start") {
              s.push("translate(".concat(labelWidth, ")"));
            } else if (textAlign === "middle") {
              s.push("translate(".concat(labelWidth / 2 + domainHeight / 2, ")"));
            } else if (textAlign === "end") {
              s.push("translate(".concat(domainHeight, ")"));
            }
            break;
        }
        return s.join(",");
      });
      break;
    case "left":
      selection.attr("transform", function(d) {
        var domainWidth = __classPrivateFieldGet(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideWidth).call(_this2, d);
        var domainHeight = __classPrivateFieldGet(_this2, _DomainLabelPainter_instances, "m", _DomainLabelPainter_getDomainInsideHeight).call(_this2, d);
        var s = ["rotate(270, ".concat(position2 === "right" ? domainWidth : labelWidth, ", 0)")];
        switch (position2) {
          case "right":
            if (textAlign === "start") {
              s.push("translate(-".concat(domainHeight, ")"));
            } else if (textAlign === "middle") {
              s.push("translate(-".concat(domainHeight / 2 + labelWidth / 2, ")"));
            } else if (textAlign === "end") {
              s.push("translate(-".concat(labelWidth, ")"));
            }
            break;
          case "left":
            if (textAlign === "start") {
              s.push("translate(".concat(labelWidth - domainHeight, ")"));
            } else if (textAlign === "middle") {
              s.push("translate(".concat(labelWidth / 2 - domainHeight / 2, ")"));
            }
            break;
        }
        return s.join(",");
      });
      break;
  }
};
var whitespaces$2 = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
var uncurryThis$8 = functionUncurryThis;
var requireObjectCoercible$3 = requireObjectCoercible$7;
var toString$5 = toString$9;
var whitespaces$1 = whitespaces$2;
var replace$2 = uncurryThis$8("".replace);
var ltrim = RegExp("^[" + whitespaces$1 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$1 + "])[" + whitespaces$1 + "]+$");
var createMethod$1 = function(TYPE) {
  return function($this) {
    var string = toString$5(requireObjectCoercible$3($this));
    if (TYPE & 1) string = replace$2(string, ltrim, "");
    if (TYPE & 2) string = replace$2(string, rtrim, "$1");
    return string;
  };
};
var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod$1(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod$1(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod$1(3)
};
var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$7 = fails$u;
var whitespaces = whitespaces$2;
var non = "âÂá ";
var stringTrimForced = function(METHOD_NAME) {
  return fails$7(function() {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$5 = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced;
$$5({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
  trim: function trim() {
    return $trim(this);
  }
});
var _SubDomainPainter_instances;
var _SubDomainPainter_setPositions;
var _SubDomainPainter_classname;
var _SubDomainPainter_appendText;
var _SubDomainPainter_getCoordinates;
var _SubDomainPainter_getX;
var _SubDomainPainter_getY;
var DEFAULT_SELECTOR$1 = ".ch-subdomain";
var HIGHLIGHT_CLASSNAME = "highlight";
var SubDomainPainter = function() {
  function SubDomainPainter2(calendar) {
    _classCallCheck(this, SubDomainPainter2);
    _SubDomainPainter_instances.add(this);
    this.calendar = calendar;
    this.root = null;
  }
  _createClass(SubDomainPainter2, [{
    key: "paint",
    value: function paint(root2) {
      var _this = this;
      this.root = root2 || this.root;
      var containerClassname = "".concat(DEFAULT_SELECTOR$1, "-container");
      var subDomainSvgGroup = this.root.selectAll(containerClassname).data(function(d) {
        return [d];
      }, function(d) {
        return d;
      }).join(function(enter) {
        return enter.append("svg").call(function(selection) {
          return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_setPositions).call(_this, selection);
        }).attr("class", containerClassname.slice(1));
      }, function(update) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          update.call(function(selection) {
            return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_setPositions).call(_this, selection);
          })
        );
      });
      var _this$calendar$option = this.calendar.options.options.subDomain, radius2 = _this$calendar$option.radius, width = _this$calendar$option.width, height = _this$calendar$option.height, sort3 = _this$calendar$option.sort;
      var evt = this.calendar.eventEmitter;
      subDomainSvgGroup.selectAll("g").data(function(d) {
        var subDomainsCollection = _this.calendar.domainCollection.get(d);
        if (sort3 === "desc") {
          var max3 = Math.max.apply(Math, _toConsumableArray(subDomainsCollection.map(function(s) {
            return s.x;
          })));
          subDomainsCollection.forEach(function(s, i) {
            subDomainsCollection[i].x = Math.abs(s.x - max3);
          });
        }
        return subDomainsCollection;
      }).join(function(enter) {
        return enter.append("g").call(function(selection) {
          return selection.insert("rect").attr("class", function(d) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_classname).call(_this, d.t, "".concat(DEFAULT_SELECTOR$1.slice(1), "-bg"))
            );
          }).attr("width", width).attr("height", height).attr("x", function(d) {
            return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getX).call(_this, d);
          }).attr("y", function(d) {
            return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getY).call(_this, d);
          }).on("click", function(ev, d) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              evt.emit("click", ev, d.t, d.v)
            );
          }).on("mouseover", function(ev, d) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              evt.emit("mouseover", ev, d.t, d.v)
            );
          }).on("mouseout", function(ev, d) {
            return (
              // eslint-disable-next-line implicit-arrow-linebreak
              evt.emit("mouseout", ev, d.t, d.v)
            );
          }).attr("rx", radius2 > 0 ? radius2 : null).attr("ry", radius2 > 0 ? radius2 : null);
        }).call(function(selection) {
          return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_appendText).call(_this, selection);
        });
      }, function(update) {
        return update.selectAll("rect").attr("class", function(d) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_classname).call(_this, d.t, "".concat(DEFAULT_SELECTOR$1.slice(1), "-bg"))
          );
        }).attr("width", width).attr("height", height).attr("x", function(d) {
          return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getX).call(_this, d);
        }).attr("y", function(d) {
          return __classPrivateFieldGet(_this, _SubDomainPainter_instances, "m", _SubDomainPainter_getY).call(_this, d);
        }).attr("rx", radius2).attr("ry", radius2);
      });
    }
  }]);
  return SubDomainPainter2;
}();
_SubDomainPainter_instances = /* @__PURE__ */ new WeakSet(), _SubDomainPainter_setPositions = function _SubDomainPainter_setPositions2(selection) {
  var options = this.calendar.options.options;
  var _options$domain = options.domain, padding = _options$domain.padding, position2 = _options$domain.label.position;
  selection.attr("x", function() {
    var pos = padding[Position.LEFT];
    if (position2 === "left") {
      pos += options.x.domainHorizontalLabelWidth;
    }
    return pos;
  }).attr("y", function() {
    var pos = padding[Position.TOP];
    if (position2 === "top") {
      pos += options.x.domainVerticalLabelHeight;
    }
    return pos;
  });
}, _SubDomainPainter_classname = function _SubDomainPainter_classname2(timestamp) {
  var _this2 = this;
  var _this$calendar$option2 = this.calendar.options.options, highlight = _this$calendar$option2.date.highlight, type = _this$calendar$option2.subDomain.type;
  var classname = "";
  if (highlight.length > 0) {
    highlight.forEach(function(d) {
      var unitFn = _this2.calendar.templateCollection.get(type).extractUnit;
      if (unitFn(+d) === unitFn(timestamp)) {
        classname = HIGHLIGHT_CLASSNAME;
      }
    });
  }
  for (var _len = arguments.length, otherClasses = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    otherClasses[_key - 1] = arguments[_key];
  }
  return [classname].concat(otherClasses).join(" ").trim();
}, _SubDomainPainter_appendText = function _SubDomainPainter_appendText2(elem) {
  var _this3 = this;
  var _this$calendar$option3 = this.calendar.options.options.subDomain, width = _this$calendar$option3.width, height = _this$calendar$option3.height, label = _this$calendar$option3.label;
  if (!label) {
    return null;
  }
  return elem.append("text").attr("class", function(d) {
    return (
      // eslint-disable-next-line implicit-arrow-linebreak
      __classPrivateFieldGet(_this3, _SubDomainPainter_instances, "m", _SubDomainPainter_classname).call(_this3, d.t, "".concat(DEFAULT_SELECTOR$1.slice(1), "-text"))
    );
  }).attr("x", function(d) {
    return __classPrivateFieldGet(_this3, _SubDomainPainter_instances, "m", _SubDomainPainter_getX).call(_this3, d) + width / 2;
  }).attr("y", function(d) {
    return __classPrivateFieldGet(_this3, _SubDomainPainter_instances, "m", _SubDomainPainter_getY).call(_this3, d) + height / 2;
  }).attr("text-anchor", "middle").attr("dominant-baseline", "central").text(function(d, i, nodes) {
    return (
      // eslint-disable-next-line implicit-arrow-linebreak
      _this3.calendar.dateHelper.format(d.t, label, d.v, nodes[i])
    );
  });
}, _SubDomainPainter_getCoordinates = function _SubDomainPainter_getCoordinates2(axis, d) {
  var subDomain = this.calendar.options.options.subDomain;
  return d[axis] * (subDomain[axis === "x" ? "width" : "height"] + subDomain.gutter);
}, _SubDomainPainter_getX = function _SubDomainPainter_getX2(d) {
  return __classPrivateFieldGet(this, _SubDomainPainter_instances, "m", _SubDomainPainter_getCoordinates).call(this, "x", d);
}, _SubDomainPainter_getY = function _SubDomainPainter_getY2(d) {
  return __classPrivateFieldGet(this, _SubDomainPainter_instances, "m", _SubDomainPainter_getCoordinates).call(this, "y", d);
};
var _DomainsContainerPainter_instances;
var _DomainsContainerPainter_startAnimation;
var _DomainsContainerPainter_endAnimation;
var _DomainsContainerPainter_recomputeDimensions;
var BASE_SELECTOR = ".ch-domain-container";
var TRANSITION_CLASSNAME = "in-transition";
var DomainsContainerPainter = function() {
  function DomainsContainerPainter2(calendar) {
    _classCallCheck(this, DomainsContainerPainter2);
    _DomainsContainerPainter_instances.add(this);
    this.calendar = calendar;
    this.domainPainter = new DomainPainter(calendar);
    this.subDomainPainter = new SubDomainPainter(calendar);
    this.domainLabelPainter = new DomainLabelPainter(calendar);
    this.dimensions = {
      width: 0,
      height: 0
    };
    this.transitionsQueueCount = 0;
  }
  _createClass(DomainsContainerPainter2, [{
    key: "setup",
    value: function setup() {
      this.root = this.calendar.calendarPainter.root.attr("x", 0).attr("y", 0).append("svg").attr("class", BASE_SELECTOR.slice(1)).append("svg").attr("class", "".concat(BASE_SELECTOR.slice(1), "-animation-wrapper"));
    }
  }, {
    key: "paint",
    value: function paint(scrollDirection) {
      var _this = this;
      __classPrivateFieldGet(this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_startAnimation).call(this);
      var result = this.domainPainter.paint(scrollDirection, this.root);
      this.subDomainPainter.paint(this.domainPainter.root);
      this.domainLabelPainter.paint(this.domainPainter.root);
      __classPrivateFieldGet(this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_recomputeDimensions).call(this);
      Promise.allSettled(result).then(function() {
        __classPrivateFieldGet(_this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_endAnimation).call(_this);
      });
      return result;
    }
  }, {
    key: "updatePosition",
    value: function updatePosition() {
      var _a;
      if (!((_a = this.root) === null || _a === void 0 ? void 0 : _a.node())) {
        return Promise.resolve();
      }
      var animationDuration = this.calendar.options.options.animationDuration;
      var topHeight = this.calendar.pluginManager.getHeightFromPosition("top");
      var leftWidth = this.calendar.pluginManager.getWidthFromPosition("left");
      return [select_default(this.root.node().parentNode).transition().duration(animationDuration).call(function(selection) {
        selection.attr("x", leftWidth).attr("y", topHeight);
      }).end()];
    }
  }, {
    key: "width",
    value: function width() {
      return this.dimensions.width;
    }
  }, {
    key: "height",
    value: function height() {
      return this.dimensions.height;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      __classPrivateFieldGet(this, _DomainsContainerPainter_instances, "m", _DomainsContainerPainter_startAnimation).call(this);
      return Promise.resolve();
    }
  }]);
  return DomainsContainerPainter2;
}();
_DomainsContainerPainter_instances = /* @__PURE__ */ new WeakSet(), _DomainsContainerPainter_startAnimation = function _DomainsContainerPainter_startAnimation2() {
  var _a;
  if ((_a = this.root) === null || _a === void 0 ? void 0 : _a.node()) {
    this.transitionsQueueCount += 1;
    select_default(this.root.node().parentNode).classed(TRANSITION_CLASSNAME, true);
  }
}, _DomainsContainerPainter_endAnimation = function _DomainsContainerPainter_endAnimation2() {
  var _a;
  if ((_a = this.root) === null || _a === void 0 ? void 0 : _a.node()) {
    this.transitionsQueueCount -= 1;
    if (this.transitionsQueueCount === 0) {
      select_default(this.root.node().parentNode).classed(TRANSITION_CLASSNAME, false);
    }
  }
}, _DomainsContainerPainter_recomputeDimensions = function _DomainsContainerPainter_recomputeDimensions2() {
  var _this$calendar$option = this.calendar.options.options, animationDuration = _this$calendar$option.animationDuration, verticalOrientation = _this$calendar$option.verticalOrientation, gutter = _this$calendar$option.domain.gutter;
  var domainsDimensions = this.domainPainter.dimensions;
  this.dimensions = {
    width: domainsDimensions.width - (verticalOrientation ? 0 : gutter),
    height: domainsDimensions.height - (!verticalOrientation ? 0 : gutter)
  };
  this.root.transition().duration(animationDuration).attr("width", this.dimensions.width).attr("height", this.dimensions.height);
};
var PluginPainter = function() {
  function PluginPainter2(calendar) {
    _classCallCheck(this, PluginPainter2);
    this.calendar = calendar;
  }
  _createClass(PluginPainter2, [{
    key: "paint",
    value: function paint() {
      var promises = [];
      promises = promises.concat(this.calendar.pluginManager.paintAll());
      promises = promises.concat(this.setPluginsPosition());
      return promises;
    }
  }, {
    key: "setPluginsPosition",
    value: function setPluginsPosition() {
      var pluginManager = this.calendar.pluginManager;
      var animationDuration = this.calendar.options.options.animationDuration;
      var domainsContainerPainter = this.calendar.calendarPainter.domainsContainerPainter;
      var top = pluginManager.getFromPosition("top");
      var right = pluginManager.getFromPosition("right");
      var bottom = pluginManager.getFromPosition("bottom");
      var left = pluginManager.getFromPosition("left");
      var topHeight = pluginManager.getHeightFromPosition("top");
      var leftWidth = pluginManager.getWidthFromPosition("left");
      var promises = [];
      var topOffset = 0;
      top.forEach(function(plugin) {
        promises.push(plugin.root.transition().duration(animationDuration).attr("y", topOffset).attr("x", leftWidth).end());
        topOffset += plugin.options.dimensions.height;
      });
      var leftOffset = 0;
      left.forEach(function(plugin) {
        promises.push(plugin.root.transition().duration(animationDuration).attr("x", leftOffset).attr("y", topHeight).end());
        leftOffset += plugin.options.dimensions.width;
      });
      bottom.forEach(function(plugin) {
        promises.push(plugin.root.transition().duration(animationDuration).attr("x", leftWidth).attr("y", topHeight + domainsContainerPainter.height()).end());
      });
      leftOffset += domainsContainerPainter.width();
      right.forEach(function(plugin) {
        promises.push(plugin.root.transition().duration(animationDuration).attr("x", leftOffset).attr("y", topHeight).end());
        leftOffset += plugin.options.dimensions.width;
      });
      return promises;
    }
  }, {
    key: "insideWidth",
    value: function insideWidth() {
      return this.calendar.pluginManager.getWidthFromPosition("left") + this.calendar.pluginManager.getWidthFromPosition("right");
    }
  }, {
    key: "insideHeight",
    value: function insideHeight() {
      return this.calendar.pluginManager.getHeightFromPosition("top") + this.calendar.pluginManager.getHeightFromPosition("bottom");
    }
  }]);
  return PluginPainter2;
}();
var _CalendarPainter_instances;
var _CalendarPainter_getHeight;
var _CalendarPainter_getWidth;
var _CalendarPainter_resize;
var DEFAULT_SELECTOR = ".ch-container";
var CalendarPainter = function() {
  function CalendarPainter2(calendar) {
    _classCallCheck(this, CalendarPainter2);
    _CalendarPainter_instances.add(this);
    this.calendar = calendar;
    this.dimensions = {
      width: 0,
      height: 0
    };
    this.root = null;
    this.domainsContainerPainter = new DomainsContainerPainter(calendar);
    this.pluginPainter = new PluginPainter(calendar);
  }
  _createClass(CalendarPainter2, [{
    key: "setup",
    value: function setup() {
      var _this$calendar$option = this.calendar.options.options, itemSelector = _this$calendar$option.itemSelector, theme = _this$calendar$option.theme;
      if (!this.root) {
        this.root = select_default(itemSelector).append("svg").attr("data-theme", theme).attr("class", DEFAULT_SELECTOR.slice(1));
        this.domainsContainerPainter.setup();
      }
      this.calendar.pluginManager.setupAll();
      return true;
    }
  }, {
    key: "paint",
    value: function paint() {
      var navigationDir = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ScrollDirection.SCROLL_NONE;
      var transitions = this.domainsContainerPainter.paint(navigationDir).concat(this.pluginPainter.paint()).concat(this.domainsContainerPainter.updatePosition());
      __classPrivateFieldGet(this, _CalendarPainter_instances, "m", _CalendarPainter_resize).call(this);
      return Promise.allSettled(transitions);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var result = this.calendar.pluginManager.destroyAll().concat(this.domainsContainerPainter.destroy());
      if (!this.root) {
        return Promise.allSettled(result);
      }
      result.push(this.root.transition().duration(this.calendar.options.options.animationDuration).attr("width", 0).attr("height", 0).remove().end());
      return Promise.allSettled(result);
    }
  }]);
  return CalendarPainter2;
}();
_CalendarPainter_instances = /* @__PURE__ */ new WeakSet(), _CalendarPainter_getHeight = function _CalendarPainter_getHeight2() {
  return this.domainsContainerPainter.height() + this.pluginPainter.insideHeight();
}, _CalendarPainter_getWidth = function _CalendarPainter_getWidth2() {
  return this.domainsContainerPainter.width() + this.pluginPainter.insideWidth();
}, _CalendarPainter_resize = function _CalendarPainter_resize2() {
  var options = this.calendar.options.options;
  var newWidth = __classPrivateFieldGet(this, _CalendarPainter_instances, "m", _CalendarPainter_getWidth).call(this);
  var newHeight = __classPrivateFieldGet(this, _CalendarPainter_instances, "m", _CalendarPainter_getHeight).call(this);
  this.root.transition().duration(options.animationDuration).attr("width", newWidth).attr("height", newHeight);
  if (newWidth !== this.dimensions.width || newHeight !== this.dimensions.height) {
    this.calendar.eventEmitter.emit("resize", newWidth, newHeight, this.dimensions.width, this.dimensions.height);
  }
  this.dimensions = {
    width: newWidth,
    height: newHeight
  };
};
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var $$4 = _export;
var toObject$1 = toObject$a;
var nativeKeys$2 = objectKeys$3;
var fails$6 = fails$u;
var FAILS_ON_PRIMITIVES = fails$6(function() {
  nativeKeys$2(1);
});
$$4({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys2(it) {
    return nativeKeys$2(toObject$1(it));
  }
});
var isObject$1 = isObject$j;
var classof$1 = classofRaw$2;
var wellKnownSymbol$3 = wellKnownSymbol$m;
var MATCH$1 = wellKnownSymbol$3("match");
var isRegexp = function(it) {
  var isRegExp2;
  return isObject$1(it) && ((isRegExp2 = it[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$1(it) === "RegExp");
};
var isRegExp = isRegexp;
var $TypeError$1 = TypeError;
var notARegexp = function(it) {
  if (isRegExp(it)) {
    throw new $TypeError$1("The method doesn't accept regular expressions");
  }
  return it;
};
var wellKnownSymbol$2 = wellKnownSymbol$m;
var MATCH = wellKnownSymbol$2("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$3 = _export;
var uncurryThis$7 = functionUncurryThisClause;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var toLength$1 = toLength$3;
var toString$4 = toString$9;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$2 = requireObjectCoercible$7;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var nativeStartsWith = uncurryThis$7("".startsWith);
var stringSlice$3 = uncurryThis$7("".slice);
var min$1 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic$1("startsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor2(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$$3({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString) {
    var that = toString$4(requireObjectCoercible$2(this));
    notARegExp$1(searchString);
    var index = toLength$1(min$1(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString$4(searchString);
    return nativeStartsWith ? nativeStartsWith(that, search, index) : stringSlice$3(that, index, index + search.length) === search;
  }
});
var DESCRIPTORS$1 = descriptors;
var fails$5 = fails$u;
var uncurryThis$6 = functionUncurryThis;
var objectGetPrototypeOf = objectGetPrototypeOf$1;
var objectKeys = objectKeys$3;
var toIndexedObject = toIndexedObject$9;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable$2 = uncurryThis$6($propertyIsEnumerable);
var push$1 = uncurryThis$6([].push);
var IE_BUG = DESCRIPTORS$1 && fails$5(function() {
  var O = /* @__PURE__ */ Object.create(null);
  O[2] = 2;
  return !propertyIsEnumerable$2(O, 2);
});
var createMethod = function(TO_ENTRIES) {
  return function(it) {
    var O = toIndexedObject(it);
    var keys4 = objectKeys(O);
    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
    var length2 = keys4.length;
    var i = 0;
    var result = [];
    var key;
    while (length2 > i) {
      key = keys4[i++];
      if (!DESCRIPTORS$1 || (IE_WORKAROUND ? key in O : propertyIsEnumerable$2(O, key))) {
        push$1(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};
var objectToArray = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};
var $$2 = _export;
var $entries = objectToArray.entries;
$$2({ target: "Object", stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});
function defined(x) {
  return x != null && !Number.isNaN(x);
}
function ascendingDefined(a, b) {
  return +defined(b) - +defined(a) || ascending(a, b);
}
function finite(x) {
  return isFinite(x) ? x : NaN;
}
function positive(x) {
  return x > 0 && isFinite(x) ? x : NaN;
}
function negative(x) {
  return x < 0 && isFinite(x) ? x : NaN;
}
var re = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
function parse(string, fallback) {
  if (!re.test(string += "")) return typeof fallback === "function" ? fallback(string) : fallback;
  return new Date(string);
}
var timeIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", timeMinute],
  ["hour", timeHour],
  ["day", timeDay],
  ["week", timeSunday],
  ["month", timeMonth],
  ["quarter", timeMonth.every(3)],
  ["half", timeMonth.every(6)],
  ["year", timeYear],
  ["monday", timeMonday],
  ["tuesday", timeTuesday],
  ["wednesday", timeWednesday],
  ["thursday", timeThursday],
  ["friday", timeFriday],
  ["saturday", timeSaturday],
  ["sunday", timeSunday]
]);
var utcIntervals = /* @__PURE__ */ new Map([
  ["second", second],
  ["minute", utcMinute],
  ["hour", utcHour],
  ["day", utcDay],
  ["week", utcSunday],
  ["month", utcMonth],
  ["quarter", utcMonth.every(3)],
  ["half", utcMonth.every(6)],
  ["year", utcYear],
  ["monday", utcMonday],
  ["tuesday", utcTuesday],
  ["wednesday", utcWednesday],
  ["thursday", utcThursday],
  ["friday", utcFriday],
  ["saturday", utcSaturday],
  ["sunday", utcSunday]
]);
function maybeTimeInterval(interval) {
  const i = timeIntervals.get(`${interval}`.toLowerCase());
  if (!i) throw new Error(`unknown interval: ${interval}`);
  return i;
}
function maybeUtcInterval(interval) {
  const i = utcIntervals.get(`${interval}`.toLowerCase());
  if (!i) throw new Error(`unknown interval: ${interval}`);
  return i;
}
var TypedArray = Object.getPrototypeOf(Uint8Array);
var objectToString = Object.prototype.toString;
var constant$1 = (x) => () => x;
function coerceNumbers(values2) {
  return values2 instanceof TypedArray ? values2 : map2(values2, coerceNumber, Float64Array);
}
function coerceNumber(x) {
  return x == null ? NaN : Number(x);
}
function coerceDates(values2) {
  return map2(values2, coerceDate);
}
function coerceDate(x) {
  return x instanceof Date && !isNaN(x) ? x : typeof x === "string" ? parse(x) : x == null || isNaN(x = +x) ? void 0 : new Date(x);
}
function arrayify(data2) {
  return data2 == null || data2 instanceof Array || data2 instanceof TypedArray ? data2 : Array.from(data2);
}
function map2(values2, f, type = Array) {
  return values2 == null ? values2 : values2 instanceof type ? values2.map(f) : type.from(values2, f);
}
function slice2(values2, type = Array) {
  return values2 instanceof type ? values2.slice() : type.from(values2);
}
function isObject(option) {
  return (option == null ? void 0 : option.toString) === objectToString;
}
function isScaleOptions(option) {
  return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
}
function maybeInterval(interval, type) {
  if (interval == null) return;
  if (typeof interval === "number") {
    if (0 < interval && interval < 1 && Number.isInteger(1 / interval)) interval = -1 / interval;
    const n = Math.abs(interval);
    return interval < 0 ? {
      floor: (d) => Math.floor(d * n) / n,
      offset: (d) => (d * n + 1) / n,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo * n), hi * n).map((x) => x / n)
    } : {
      floor: (d) => Math.floor(d / n) * n,
      offset: (d) => d + n,
      // note: no optional step for simplicity
      range: (lo, hi) => range(Math.ceil(lo / n), hi / n).map((x) => x * n)
    };
  }
  if (typeof interval === "string") return (type === "time" ? maybeTimeInterval : maybeUtcInterval)(interval);
  if (typeof interval.floor !== "function") throw new Error("invalid interval; missing floor method");
  if (typeof interval.offset !== "function") throw new Error("invalid interval; missing offset method");
  return interval;
}
function maybeRangeInterval(interval, type) {
  interval = maybeInterval(interval, type);
  if (interval && typeof interval.range !== "function") throw new Error("invalid interval: missing range method");
  return interval;
}
function maybeNiceInterval(interval, type) {
  interval = maybeRangeInterval(interval, type);
  if (interval && typeof interval.ceil !== "function") throw new Error("invalid interval: missing ceil method");
  return interval;
}
function isOrdinal(values2) {
  for (const value of values2) {
    if (value == null) continue;
    const type = typeof value;
    return type === "string" || type === "boolean";
  }
}
function isTemporal(values2) {
  for (const value of values2) {
    if (value == null) continue;
    return value instanceof Date;
  }
}
function isTemporalString(values2) {
  for (const value of values2) {
    if (value == null) continue;
    return typeof value === "string" && isNaN(value) && parse(value);
  }
}
function isNumericString(values2) {
  for (const value of values2) {
    if (value == null) continue;
    if (typeof value !== "string") return false;
    if (!value.trim()) continue;
    return !isNaN(value);
  }
}
function isNoneish(value) {
  return value == null || isNone(value);
}
function isNone(value) {
  return /^\s*none\s*$/i.test(value);
}
function orderof(values2) {
  if (values2 == null) return;
  const first = values2[0];
  const last = values2[values2.length - 1];
  return descending(first, last);
}
var position = Symbol("position");
var color = Symbol("color");
var radius = Symbol("radius");
var length = Symbol("length");
var opacity = Symbol("opacity");
var symbol = Symbol("symbol");
var registry = /* @__PURE__ */ new Map([
  ["x", position],
  ["y", position],
  ["fx", position],
  ["fy", position],
  ["r", radius],
  ["color", color],
  ["opacity", opacity],
  ["symbol", symbol],
  ["length", length]
]);
var sqrt3 = Math.sqrt(3);
var sqrt4_3 = 2 / sqrt3;
var symbolHexagon = {
  draw(context, size) {
    const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
    context.moveTo(0, ry);
    context.lineTo(rx, hy);
    context.lineTo(rx, -hy);
    context.lineTo(0, -ry);
    context.lineTo(-rx, -hy);
    context.lineTo(-rx, hy);
    context.closePath();
  }
};
var symbols = /* @__PURE__ */ new Map([
  ["asterisk", asterisk_default],
  ["circle", circle_default],
  ["cross", cross_default],
  ["diamond", diamond_default],
  ["diamond2", diamond2_default],
  ["hexagon", symbolHexagon],
  ["plus", plus_default],
  ["square", square_default],
  ["square2", square2_default],
  ["star", star_default],
  ["times", times_default],
  ["triangle", triangle_default],
  ["triangle2", triangle2_default],
  ["wye", wye_default]
]);
function isSymbolObject(value) {
  return value && typeof value.draw === "function";
}
function maybeSymbol(symbol2) {
  if (symbol2 == null || isSymbolObject(symbol2)) return symbol2;
  const value = symbols.get(`${symbol2}`.toLowerCase());
  if (value) return value;
  throw new Error(`invalid symbol: ${symbol2}`);
}
function warn(message) {
  console.warn(message);
}
var ordinalSchemes = /* @__PURE__ */ new Map([
  // categorical
  ["accent", Accent_default],
  ["category10", category10_default],
  ["dark2", Dark2_default],
  ["paired", Paired_default],
  ["pastel1", Pastel1_default],
  ["pastel2", Pastel2_default],
  ["set1", Set1_default],
  ["set2", Set2_default],
  ["set3", Set3_default],
  ["tableau10", Tableau10_default],
  // diverging
  ["brbg", scheme112(scheme, BrBG_default)],
  ["prgn", scheme112(scheme2, PRGn_default)],
  ["piyg", scheme112(scheme3, PiYG_default)],
  ["puor", scheme112(scheme4, PuOr_default)],
  ["rdbu", scheme112(scheme5, RdBu_default)],
  ["rdgy", scheme112(scheme6, RdGy_default)],
  ["rdylbu", scheme112(scheme7, RdYlBu_default)],
  ["rdylgn", scheme112(scheme8, RdYlGn_default)],
  ["spectral", scheme112(scheme9, Spectral_default)],
  // reversed diverging (for temperature data)
  ["burd", scheme11r(scheme5, RdBu_default)],
  ["buylrd", scheme11r(scheme7, RdYlBu_default)],
  // sequential (single-hue)
  ["blues", scheme92(scheme22, Blues_default)],
  ["greens", scheme92(scheme23, Greens_default)],
  ["greys", scheme92(scheme24, Greys_default)],
  ["oranges", scheme92(scheme27, Oranges_default)],
  ["purples", scheme92(scheme25, Purples_default)],
  ["reds", scheme92(scheme26, Reds_default)],
  // sequential (multi-hue)
  ["turbo", schemei(turbo_default)],
  ["viridis", schemei(viridis_default)],
  ["magma", schemei(magma)],
  ["inferno", schemei(inferno)],
  ["plasma", schemei(plasma)],
  ["cividis", schemei(cividis_default)],
  ["cubehelix", schemei(cubehelix_default)],
  ["warm", schemei(warm)],
  ["cool", schemei(cool)],
  ["bugn", scheme92(scheme10, BuGn_default)],
  ["bupu", scheme92(scheme11, BuPu_default)],
  ["gnbu", scheme92(scheme12, GnBu_default)],
  ["orrd", scheme92(scheme13, OrRd_default)],
  ["pubu", scheme92(scheme15, PuBu_default)],
  ["pubugn", scheme92(scheme14, PuBuGn_default)],
  ["purd", scheme92(scheme16, PuRd_default)],
  ["rdpu", scheme92(scheme17, RdPu_default)],
  ["ylgn", scheme92(scheme19, YlGn_default)],
  ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
  ["ylorbr", scheme92(scheme20, YlOrBr_default)],
  ["ylorrd", scheme92(scheme21, YlOrRd_default)],
  // cyclical
  ["rainbow", schemeicyclical(rainbow_default)],
  ["sinebow", schemeicyclical(sinebow_default)]
]);
function scheme92(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 1) return [scheme28[3][1]];
    if (n === 2) return [scheme28[3][1], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 9 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme112(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2) return [scheme28[3][0], scheme28[3][2]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default(interpolate, n) : scheme28[n];
  };
}
function scheme11r(scheme28, interpolate) {
  return ({ length: n }) => {
    if (n === 2) return [scheme28[3][2], scheme28[3][0]];
    n = Math.max(3, Math.floor(n));
    return n > 11 ? quantize_default((t) => interpolate(1 - t), n) : scheme28[n].slice().reverse();
  };
}
function schemei(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.max(2, Math.floor(n)));
}
function schemeicyclical(interpolate) {
  return ({ length: n }) => quantize_default(interpolate, Math.floor(n) + 1).slice(0, -1);
}
function ordinalScheme(scheme28) {
  const s = `${scheme28}`.toLowerCase();
  if (!ordinalSchemes.has(s)) throw new Error(`unknown ordinal scheme: ${s}`);
  return ordinalSchemes.get(s);
}
function ordinalRange(scheme28, length2) {
  const s = ordinalScheme(scheme28);
  const r = typeof s === "function" ? s({ length: length2 }) : s;
  return r.length !== length2 ? r.slice(0, length2) : r;
}
function maybeBooleanRange(domain, scheme28 = "greys") {
  const range3 = /* @__PURE__ */ new Set();
  const [f, t] = ordinalRange(scheme28, 2);
  for (const value of domain) {
    if (value == null) continue;
    if (value === true) range3.add(t);
    else if (value === false) range3.add(f);
    else return;
  }
  return [...range3];
}
var quantitativeSchemes = /* @__PURE__ */ new Map([
  // diverging
  ["brbg", BrBG_default],
  ["prgn", PRGn_default],
  ["piyg", PiYG_default],
  ["puor", PuOr_default],
  ["rdbu", RdBu_default],
  ["rdgy", RdGy_default],
  ["rdylbu", RdYlBu_default],
  ["rdylgn", RdYlGn_default],
  ["spectral", Spectral_default],
  // reversed diverging (for temperature data)
  ["burd", (t) => RdBu_default(1 - t)],
  ["buylrd", (t) => RdYlBu_default(1 - t)],
  // sequential (single-hue)
  ["blues", Blues_default],
  ["greens", Greens_default],
  ["greys", Greys_default],
  ["purples", Purples_default],
  ["reds", Reds_default],
  ["oranges", Oranges_default],
  // sequential (multi-hue)
  ["turbo", turbo_default],
  ["viridis", viridis_default],
  ["magma", magma],
  ["inferno", inferno],
  ["plasma", plasma],
  ["cividis", cividis_default],
  ["cubehelix", cubehelix_default],
  ["warm", warm],
  ["cool", cool],
  ["bugn", BuGn_default],
  ["bupu", BuPu_default],
  ["gnbu", GnBu_default],
  ["orrd", OrRd_default],
  ["pubugn", PuBuGn_default],
  ["pubu", PuBu_default],
  ["purd", PuRd_default],
  ["rdpu", RdPu_default],
  ["ylgnbu", YlGnBu_default],
  ["ylgn", YlGn_default],
  ["ylorbr", YlOrBr_default],
  ["ylorrd", YlOrRd_default],
  // cyclical
  ["rainbow", rainbow_default],
  ["sinebow", sinebow_default]
]);
function quantitativeScheme(scheme28) {
  const s = `${scheme28}`.toLowerCase();
  if (!quantitativeSchemes.has(s)) throw new Error(`unknown quantitative scheme: ${s}`);
  return quantitativeSchemes.get(s);
}
var divergingSchemes = /* @__PURE__ */ new Set([
  "brbg",
  "prgn",
  "piyg",
  "puor",
  "rdbu",
  "rdgy",
  "rdylbu",
  "rdylgn",
  "spectral",
  "burd",
  "buylrd"
]);
function isDivergingScheme(scheme28) {
  return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
}
var flip = (i) => (t) => i(1 - t);
var unit = [0, 1];
var interpolators = /* @__PURE__ */ new Map([
  // numbers
  ["number", number_default],
  // color spaces
  ["rgb", rgb_default],
  ["hsl", hsl_default],
  ["hcl", hcl_default],
  ["lab", lab]
]);
function maybeInterpolator(interpolate) {
  const i = `${interpolate}`.toLowerCase();
  if (!interpolators.has(i)) throw new Error(`unknown interpolator: ${i}`);
  return interpolators.get(i);
}
function createScaleQ(key, scale2, channels, {
  type,
  nice,
  clamp,
  zero,
  domain = inferAutoDomain(key, channels),
  unknown,
  round,
  scheme: scheme28,
  interval,
  range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit : void 0,
  interpolate = registry.get(key) === color ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type === "cyclical" ? "rainbow" : "turbo") : round ? round_default : number_default,
  reverse: reverse$1
}) {
  interval = maybeRangeInterval(interval, type);
  if (type === "cyclical" || type === "sequential") type = "linear";
  reverse$1 = !!reverse$1;
  if (typeof interpolate !== "function") {
    interpolate = maybeInterpolator(interpolate);
  }
  if (interpolate.length === 1) {
    if (reverse$1) {
      interpolate = flip(interpolate);
      reverse$1 = false;
    }
    if (range3 === void 0) {
      range3 = Float64Array.from(domain, (_, i) => i / (domain.length - 1));
      if (range3.length === 2) range3 = unit;
    }
    scale2.interpolate((range3 === unit ? constant$1 : interpolatePiecewise)(interpolate));
  } else {
    scale2.interpolate(interpolate);
  }
  if (zero) {
    const [min3, max3] = extent(domain);
    if (min3 > 0 || max3 < 0) {
      domain = slice2(domain);
      if (orderof(domain) !== Math.sign(min3)) domain[domain.length - 1] = 0;
      else domain[0] = 0;
    }
  }
  if (reverse$1) domain = reverse(domain);
  scale2.domain(domain).unknown(unknown);
  if (nice) scale2.nice(maybeNice(nice, type)), domain = scale2.domain();
  if (range3 !== void 0) scale2.range(range3);
  if (clamp) scale2.clamp(clamp);
  return { type, domain, range: range3, scale: scale2, interpolate, interval };
}
function maybeNice(nice, type) {
  return nice === true ? void 0 : typeof nice === "number" ? nice : maybeNiceInterval(nice, type);
}
function createScaleLinear(key, channels, options) {
  return createScaleQ(key, linear(), channels, options);
}
function createScaleSqrt(key, channels, options) {
  return createScalePow(key, channels, { ...options, exponent: 0.5 });
}
function createScalePow(key, channels, { exponent = 1, ...options }) {
  return createScaleQ(key, pow().exponent(exponent), channels, { ...options, type: "pow" });
}
function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
  return createScaleQ(key, log().base(base), channels, { ...options, domain });
}
function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleQ(key, symlog().constant(constant2), channels, options);
}
function createScaleQuantile(key, channels, {
  range: range3,
  quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  // deprecated; use n instead
  n = quantiles,
  scheme: scheme28 = "rdylbu",
  domain = inferQuantileDomain(channels),
  unknown,
  interpolate,
  reverse: reverse2
}) {
  if (range3 === void 0) {
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color ? ordinalRange(scheme28, n) : void 0;
  }
  if (domain.length > 0) {
    domain = quantile2(domain, range3 === void 0 ? { length: n } : range3).quantiles();
  }
  return createScaleThreshold(key, channels, { domain, range: range3, reverse: reverse2, unknown });
}
function createScaleQuantize(key, channels, {
  range: range3,
  n = range3 === void 0 ? 5 : (range3 = [...range3]).length,
  scheme: scheme28 = "rdylbu",
  domain = inferAutoDomain(key, channels),
  unknown,
  interpolate,
  reverse: reverse2
}) {
  const [min3, max3] = extent(domain);
  let thresholds;
  if (range3 === void 0) {
    thresholds = ticks(min3, max3, n);
    if (thresholds[0] <= min3) thresholds.splice(0, 1);
    if (thresholds[thresholds.length - 1] >= max3) thresholds.pop();
    n = thresholds.length + 1;
    range3 = interpolate !== void 0 ? quantize_default(interpolate, n) : registry.get(key) === color ? ordinalRange(scheme28, n) : void 0;
  } else {
    thresholds = quantize_default(number_default(min3, max3), n + 1).slice(1, -1);
    if (min3 instanceof Date) thresholds = thresholds.map((x) => new Date(x));
  }
  if (orderof(arrayify(domain)) < 0) thresholds.reverse();
  return createScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse2, unknown });
}
function createScaleThreshold(key, channels, {
  domain = [0],
  // explicit thresholds in ascending order
  unknown,
  scheme: scheme28 = "rdylbu",
  interpolate,
  range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color ? ordinalRange(scheme28, domain.length + 1) : void 0,
  reverse: reverse$1
}) {
  domain = arrayify(domain);
  const sign = orderof(domain);
  if (!isNaN(sign) && !isOrdered(domain, sign)) throw new Error(`the ${key} scale has a non-monotonic domain`);
  if (reverse$1) range3 = reverse(range3);
  return {
    type: "threshold",
    scale: threshold(sign < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
    domain,
    range: range3
  };
}
function isOrdered(domain, sign) {
  for (let i = 1, n = domain.length, d = domain[0]; i < n; ++i) {
    const s = descending(d, d = domain[i]);
    if (s !== 0 && s !== sign) return false;
  }
  return true;
}
function createScaleIdentity() {
  return { type: "identity", scale: identity() };
}
function inferDomain$1(channels, f = finite) {
  return channels.length ? [
    min(channels, ({ value }) => value === void 0 ? value : min(value, f)),
    max(channels, ({ value }) => value === void 0 ? value : max(value, f))
  ] : [0, 1];
}
function inferAutoDomain(key, channels) {
  const type = registry.get(key);
  return (type === radius || type === opacity || type === length ? inferZeroDomain : inferDomain$1)(channels);
}
function inferZeroDomain(channels) {
  return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite)) : 1];
}
function inferRadialRange(channels, domain) {
  const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
  if (hint !== void 0) return [0, hint.radius];
  const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
  const range3 = domain.map((d) => 3 * Math.sqrt(d / h25));
  const k = 30 / max(range3);
  return k < 1 ? range3.map((r) => r * k) : range3;
}
function inferLengthRange(channels, domain) {
  const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
  const range3 = domain.map((d) => 12 * d / h50);
  const k = 60 / max(range3);
  return k < 1 ? range3.map((r) => r * k) : range3;
}
function inferLogDomain(channels) {
  for (const { value } of channels) {
    if (value !== void 0) {
      for (let v of value) {
        if (v > 0) return inferDomain$1(channels, positive);
        if (v < 0) return inferDomain$1(channels, negative);
      }
    }
  }
  return [1, 10];
}
function inferQuantileDomain(channels) {
  const domain = [];
  for (const { value } of channels) {
    if (value === void 0) continue;
    for (const v of value) domain.push(v);
  }
  return domain;
}
function interpolatePiecewise(interpolate) {
  return (i, j) => (t) => interpolate(i + t * (j - i));
}
function createScaleD(key, scale2, transform, channels, {
  type,
  nice,
  clamp,
  domain = inferDomain$1(channels),
  unknown,
  pivot = 0,
  scheme: scheme28,
  range: range3,
  symmetric = true,
  interpolate = registry.get(key) === color ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
  reverse: reverse2
}) {
  pivot = +pivot;
  let [min3, max3] = domain;
  if (descending(min3, max3) < 0) [min3, max3] = [max3, min3], reverse2 = !reverse2;
  min3 = Math.min(min3, pivot);
  max3 = Math.max(max3, pivot);
  if (typeof interpolate !== "function") {
    interpolate = maybeInterpolator(interpolate);
  }
  if (range3 !== void 0) {
    interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
  }
  if (reverse2) interpolate = flip(interpolate);
  if (symmetric) {
    const mid = transform.apply(pivot);
    const mindelta = mid - transform.apply(min3);
    const maxdelta = transform.apply(max3) - mid;
    if (mindelta < maxdelta) min3 = transform.invert(mid - maxdelta);
    else if (mindelta > maxdelta) max3 = transform.invert(mid + mindelta);
  }
  scale2.domain([min3, pivot, max3]).unknown(unknown).interpolator(interpolate);
  if (clamp) scale2.clamp(clamp);
  if (nice) scale2.nice(nice);
  return { type, domain: [min3, max3], pivot, interpolate, scale: scale2 };
}
function createScaleDiverging(key, channels, options) {
  return createScaleD(key, diverging(), transformIdentity, channels, options);
}
function createScaleDivergingSqrt(key, channels, options) {
  return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
}
function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
  return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow(exponent), channels, {
    ...options,
    type: "diverging-pow"
  });
}
function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain$1(channels, pivot < 0 ? negative : positive), ...options }) {
  return createScaleD(key, divergingLog().base(base = +base), transformLog, channels, {
    domain,
    pivot,
    ...options
  });
}
function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
  return createScaleD(
    key,
    divergingSymlog().constant(constant2 = +constant2),
    transformSymlog(constant2),
    channels,
    options
  );
}
var transformIdentity = {
  apply(x) {
    return x;
  },
  invert(x) {
    return x;
  }
};
var transformLog = {
  apply: Math.log,
  invert: Math.exp
};
var transformSqrt = {
  apply(x) {
    return Math.sign(x) * Math.sqrt(Math.abs(x));
  },
  invert(x) {
    return Math.sign(x) * (x * x);
  }
};
function transformPow(exponent) {
  return exponent === 0.5 ? transformSqrt : {
    apply(x) {
      return Math.sign(x) * Math.pow(Math.abs(x), exponent);
    },
    invert(x) {
      return Math.sign(x) * Math.pow(Math.abs(x), 1 / exponent);
    }
  };
}
function transformSymlog(constant2) {
  return {
    apply(x) {
      return Math.sign(x) * Math.log1p(Math.abs(x / constant2));
    },
    invert(x) {
      return Math.sign(x) * Math.expm1(Math.abs(x)) * constant2;
    }
  };
}
function createScaleT(key, scale2, channels, options) {
  return createScaleQ(key, scale2, channels, options);
}
function createScaleTime(key, channels, options) {
  return createScaleT(key, time(), channels, options);
}
function createScaleUtc(key, channels, options) {
  return createScaleT(key, utcTime(), channels, options);
}
var ordinalImplicit = Symbol("ordinal");
function createScaleO(key, scale2, channels, { type, interval, domain, range: range3, reverse: reverse$1, hint }) {
  interval = maybeRangeInterval(interval, type);
  if (domain === void 0) domain = inferDomain(channels, interval, key);
  if (type === "categorical" || type === ordinalImplicit) type = "ordinal";
  if (reverse$1) domain = reverse(domain);
  scale2.domain(domain);
  if (range3 !== void 0) {
    if (typeof range3 === "function") range3 = range3(domain);
    scale2.range(range3);
  }
  return { type, domain, range: range3, scale: scale2, hint, interval };
}
function createScaleOrdinal(key, channels, { type, interval, domain, range: range3, scheme: scheme28, unknown, ...options }) {
  interval = maybeRangeInterval(interval, type);
  if (domain === void 0) domain = inferDomain(channels, interval, key);
  let hint;
  if (registry.get(key) === symbol) {
    hint = inferSymbolHint(channels);
    range3 = range3 === void 0 ? inferSymbolRange(hint) : map2(range3, maybeSymbol);
  } else if (registry.get(key) === color) {
    if (range3 === void 0 && (type === "ordinal" || type === ordinalImplicit)) {
      range3 = maybeBooleanRange(domain, scheme28);
      if (range3 !== void 0) scheme28 = void 0;
    }
    if (scheme28 === void 0 && range3 === void 0) {
      scheme28 = type === "ordinal" ? "turbo" : "tableau10";
    }
    if (scheme28 !== void 0) {
      if (range3 !== void 0) {
        const interpolate = quantitativeScheme(scheme28);
        const t0 = range3[0], d = range3[1] - range3[0];
        range3 = ({ length: n }) => quantize_default((t) => interpolate(t0 + d * t), n);
      } else {
        range3 = ordinalScheme(scheme28);
      }
    }
  }
  if (unknown === implicit) {
    throw new Error(`implicit unknown on ${key} scale is not supported`);
  }
  return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type, domain, range: range3, hint });
}
function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
  return maybeRound(point().align(align).padding(padding), channels, options, key);
}
function createScaleBand(key, channels, {
  align = 0.5,
  padding = 0.1,
  paddingInner = padding,
  paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
  ...options
}) {
  return maybeRound(
    band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
    channels,
    options,
    key
  );
}
function maybeRound(scale2, channels, options, key) {
  let { round } = options;
  if (round !== void 0) scale2.round(round = !!round);
  scale2 = createScaleO(key, scale2, channels, options);
  scale2.round = round;
  return scale2;
}
function inferDomain(channels, interval, key) {
  const values2 = new InternSet();
  for (const { value, domain } of channels) {
    if (domain !== void 0) return domain();
    if (value === void 0) continue;
    for (const v of value) values2.add(v);
  }
  if (interval !== void 0) {
    const [min3, max3] = extent(values2).map(interval.floor, interval);
    return interval.range(min3, interval.offset(max3));
  }
  if (values2.size > 1e4 && registry.get(key) === position) {
    throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
  }
  return sort(values2, ascendingDefined);
}
function inferHint(channels, key) {
  let value;
  for (const { hint } of channels) {
    const candidate = hint == null ? void 0 : hint[key];
    if (candidate === void 0) continue;
    if (value === void 0) value = candidate;
    else if (value !== candidate) return;
  }
  return value;
}
function inferSymbolHint(channels) {
  return {
    fill: inferHint(channels, "fill"),
    stroke: inferHint(channels, "stroke")
  };
}
function inferSymbolRange(hint) {
  return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
}
function normalizeScale(key, scale2, hint) {
  return createScale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale2 });
}
function createScale(key, channels = [], options = {}) {
  const type = inferScaleType(key, channels, options);
  if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type })) {
    const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
    if (values2.some(isTemporal))
      warn(
        `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type
        )}".`
      );
    else if (values2.some(isTemporalString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
          type
        )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type
        )}".`
      );
    else if (values2.some(isNumericString))
      warn(
        `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
          type
        )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
          type
        )}".`
      );
  }
  options.type = type;
  switch (type) {
    case "diverging":
    case "diverging-sqrt":
    case "diverging-pow":
    case "diverging-log":
    case "diverging-symlog":
    case "cyclical":
    case "sequential":
    case "linear":
    case "sqrt":
    case "threshold":
    case "quantile":
    case "pow":
    case "log":
    case "symlog":
      options = coerceType(channels, options, coerceNumbers);
      break;
    case "identity":
      switch (registry.get(key)) {
        case position:
          options = coerceType(channels, options, coerceNumbers);
          break;
        case symbol:
          options = coerceType(channels, options, coerceSymbols);
          break;
      }
      break;
    case "utc":
    case "time":
      options = coerceType(channels, options, coerceDates);
      break;
  }
  switch (type) {
    case "diverging":
      return createScaleDiverging(key, channels, options);
    case "diverging-sqrt":
      return createScaleDivergingSqrt(key, channels, options);
    case "diverging-pow":
      return createScaleDivergingPow(key, channels, options);
    case "diverging-log":
      return createScaleDivergingLog(key, channels, options);
    case "diverging-symlog":
      return createScaleDivergingSymlog(key, channels, options);
    case "categorical":
    case "ordinal":
    case ordinalImplicit:
      return createScaleOrdinal(key, channels, options);
    case "cyclical":
    case "sequential":
    case "linear":
      return createScaleLinear(key, channels, options);
    case "sqrt":
      return createScaleSqrt(key, channels, options);
    case "threshold":
      return createScaleThreshold(key, channels, options);
    case "quantile":
      return createScaleQuantile(key, channels, options);
    case "quantize":
      return createScaleQuantize(key, channels, options);
    case "pow":
      return createScalePow(key, channels, options);
    case "log":
      return createScaleLog(key, channels, options);
    case "symlog":
      return createScaleSymlog(key, channels, options);
    case "utc":
      return createScaleUtc(key, channels, options);
    case "time":
      return createScaleTime(key, channels, options);
    case "point":
      return createScalePoint(key, channels, options);
    case "band":
      return createScaleBand(key, channels, options);
    case "identity":
      return registry.get(key) === position ? createScaleIdentity() : { type: "identity" };
    case void 0:
      return;
    default:
      throw new Error(`unknown scale type: ${type}`);
  }
}
function formatScaleType(type) {
  return typeof type === "symbol" ? type.description : type;
}
var typeProjection = { toString: () => "projection" };
function inferScaleType(key, channels, { type, domain, range: range3, scheme: scheme28, pivot, projection }) {
  if (key === "fx" || key === "fy") return "band";
  if ((key === "x" || key === "y") && projection != null) type = typeProjection;
  for (const { type: t } of channels) {
    if (t === void 0) continue;
    else if (type === void 0) type = t;
    else if (type !== t) throw new Error(`scale incompatible with channel: ${type} !== ${t}`);
  }
  if (type === typeProjection) return;
  if (type !== void 0) return type;
  if (domain === void 0 && !channels.some(({ value }) => value !== void 0)) return;
  const kind = registry.get(key);
  if (kind === radius) return "sqrt";
  if (kind === opacity || kind === length) return "linear";
  if (kind === symbol) return "ordinal";
  if ((domain || range3 || []).length > 2) return asOrdinalType(kind);
  if (domain !== void 0) {
    if (isOrdinal(domain)) return asOrdinalType(kind);
    if (isTemporal(domain)) return "utc";
    if (kind === color && (pivot != null || isDivergingScheme(scheme28))) return "diverging";
    return "linear";
  }
  const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
  if (values2.some(isOrdinal)) return asOrdinalType(kind);
  if (values2.some(isTemporal)) return "utc";
  if (kind === color && (pivot != null || isDivergingScheme(scheme28))) return "diverging";
  return "linear";
}
function asOrdinalType(kind) {
  switch (kind) {
    case position:
      return "point";
    case color:
      return ordinalImplicit;
    default:
      return "ordinal";
  }
}
function isOrdinalScale({ type }) {
  return type === "ordinal" || type === "point" || type === "band" || type === ordinalImplicit;
}
function coerceType(channels, { domain, ...options }, coerceValues) {
  for (const c of channels) {
    if (c.value !== void 0) {
      c.value = coerceValues(c.value);
    }
  }
  return {
    domain: domain === void 0 ? domain : coerceValues(domain),
    ...options
  };
}
function coerceSymbols(values2) {
  return map2(values2, maybeSymbol);
}
function scale(options = {}) {
  let scale2;
  for (const key in options) {
    if (!registry.has(key)) continue;
    if (!isScaleOptions(options[key])) continue;
    if (scale2 !== void 0) throw new Error("ambiguous scale definition; multiple scales found");
    scale2 = exposeScale(normalizeScale(key, options[key]));
  }
  if (scale2 === void 0) throw new Error("invalid scale definition; no scale found");
  return scale2;
}
function exposeScale({ scale: scale2, type, domain, range: range3, interpolate, interval, transform, percent, pivot }) {
  if (type === "identity") return { type: "identity", apply: (d) => d, invert: (d) => d };
  const unknown = scale2.unknown ? scale2.unknown() : void 0;
  return {
    type,
    domain: slice2(domain),
    // defensive copy
    ...range3 !== void 0 && { range: slice2(range3) },
    // defensive copy
    ...transform !== void 0 && { transform },
    ...percent && { percent },
    // only exposed if truthy
    ...unknown !== void 0 && { unknown },
    ...interval !== void 0 && { interval },
    // quantitative
    ...interpolate !== void 0 && { interpolate },
    ...scale2.clamp && { clamp: scale2.clamp() },
    // diverging (always asymmetric; we never want to apply the symmetric transform twice)
    ...pivot !== void 0 && { pivot, symmetric: false },
    // log, diverging-log
    ...scale2.base && { base: scale2.base() },
    // pow, diverging-pow
    ...scale2.exponent && { exponent: scale2.exponent() },
    // symlog, diverging-symlog
    ...scale2.constant && { constant: scale2.constant() },
    // band, point
    ...scale2.align && { align: scale2.align(), round: scale2.round() },
    ...scale2.padding && (scale2.paddingInner ? { paddingInner: scale2.paddingInner(), paddingOuter: scale2.paddingOuter() } : { padding: scale2.padding() }),
    ...scale2.bandwidth && { bandwidth: scale2.bandwidth(), step: scale2.step() },
    // utilities
    apply: (t) => scale2(t),
    ...scale2.invert && { invert: (t) => scale2.invert(t) }
  };
}
function normalizedScale(scaleOptions) {
  try {
    var scaleType = Object.keys(scaleOptions)[0];
    return scale(_defineProperty({}, scaleType, Object.assign(Object.assign({}, scaleOptions[scaleType]), {
      clamp: true
    })));
  } catch (error) {
    return null;
  }
}
function scaleStyle(_scale, scaleOptions) {
  var styles = {};
  if (scaleOptions.hasOwnProperty("opacity")) {
    styles.fill = function() {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        scaleOptions.opacity.baseColor || SCALE_BASE_OPACITY_COLOR
      );
    };
    styles["fill-opacity"] = function(d) {
      return _scale === null || _scale === void 0 ? void 0 : _scale.apply(d);
    };
  } else {
    styles.fill = function(d) {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        typeof d === "string" && (d === null || d === void 0 ? void 0 : d.startsWith("#")) ? d : _scale === null || _scale === void 0 ? void 0 : _scale.apply(d)
      );
    };
  }
  return styles;
}
function applyScaleStyle(elem, _scale, scaleOptions, keyname) {
  Object.entries(scaleStyle(_scale, scaleOptions)).forEach(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), prop = _ref2[0], val = _ref2[1];
    return (
      // eslint-disable-next-line implicit-arrow-linebreak
      elem.style(prop, function(d) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          val(keyname ? d[keyname] : d)
        );
      })
    );
  });
}
var Populator = function() {
  function Populator2(calendar) {
    _classCallCheck(this, Populator2);
    this.calendar = calendar;
  }
  _createClass(Populator2, [{
    key: "populate",
    value: function populate() {
      var calendar = this.calendar;
      var _calendar$options$opt = calendar.options.options, scale2 = _calendar$options$opt.scale, subDomain = _calendar$options$opt.subDomain;
      var colorScale = normalizedScale(scale2);
      calendar.calendarPainter.root.selectAll(".ch-domain").selectAll("svg").selectAll("g").data(function(d) {
        return calendar.domainCollection.get(d) || [];
      }).call(function(element) {
        applyScaleStyle(element.select("rect"), colorScale, scale2, "v");
      }).call(function(element) {
        element.select("text").attr("style", function(d) {
          var defaultColor = hcl(colorScale === null || colorScale === void 0 ? void 0 : colorScale.apply(d.v)).l > 60 ? "#000" : "#fff";
          var color2 = subDomain.color || (d.v ? defaultColor : null);
          if (isFunction(color2)) {
            color2 = color2(d.t, d.v, colorScale === null || colorScale === void 0 ? void 0 : colorScale.apply(d.v));
          }
          if (!color2) {
            return null;
          }
          return "fill: ".concat(color2, ";");
        }).text(function(d, i, nodes) {
          return (
            // eslint-disable-next-line implicit-arrow-linebreak
            calendar.dateHelper.format(d.t, subDomain.label, d.v, nodes[i])
          );
        });
      }).call(function() {
        calendar.eventEmitter.emit("fill");
      });
    }
  }]);
  return Populator2;
}();
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index = assocIndexOf(data2, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data2 = this.__data__, index = assocIndexOf(data2, key);
  return index < 0 ? void 0 : data2[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data2 = this.__data__, index = assocIndexOf(data2, key);
  if (index < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index][1] = value;
  }
  return this;
}
function ListCache(entries2) {
  var index = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length2) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype;
var objectProto$d = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$2(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$c = Object.prototype;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate$1) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$a.call(data2, key) ? data2[key] : void 0;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$9.call(data2, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries2) {
  var index = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length2) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map3, key) {
  var data2 = map3.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
function MapCache(entries2) {
  var index = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length2) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
function Stack(entries2) {
  var data2 = this.__data__ = new ListCache(entries2);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var defineProperty3 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty3;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
var allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
  buffer.copy(result);
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
  var index = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index < length2) {
    array[index] = source[index];
  }
  return array;
}
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectProto$a = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value === proto;
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype;
var objectProto$8 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$7.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag = "[object Function]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$2 = "[object String]";
var weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$2 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length2 = props.length;
  while (++index < length2) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$3(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$2(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$3(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$3(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$2(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function identity2(value) {
  return value;
}
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
    while (++index < length2) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply$1(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty$1 ? identity2 : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity2), func + "");
}
function isIterateeCall(value, index, object) {
  if (!isObject$2(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index < length2) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith$1 = mergeWith;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index < length2) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map3) {
  var index = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function setToArray(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var COMPARE_UNORDERED_FLAG = 2;
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var mapTag$1 = "[object Map]";
var numberTag = "[object Number]";
var regexpTag = "[object RegExp]";
var setTag$1 = "[object Set]";
var stringTag$1 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag$1:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values2) {
  var index = -1, length2 = values2.length, offset = array.length;
  while (++index < length2) {
    array[offset + index] = values2[index];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$3(object) ? result : arrayPush(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length2) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$4 = Object.prototype;
var propertyIsEnumerable2 = objectProto$4.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol2) {
    return propertyIsEnumerable2.call(object, symbol2);
  });
};
var getSymbols$1 = getSymbols;
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys3, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var WeakMap = getNative(root$1, "WeakMap");
var WeakMap$1 = WeakMap;
var mapTag = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag = "[object Set]";
var weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1);
var mapCtorString = toSource(Map$2);
var promiseCtorString = toSource(Promise$2);
var setCtorString = toSource(Set$2);
var weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$3(object), othIsArr = isArray$3(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$3(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function arrayMap(array, iteratee) {
  var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$3(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toString$3(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$3(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString$3(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1, length2 = path.length, result = false;
  while (++index < length2) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray$3(object) || isArguments$1(object));
}
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0, length2 = path.length;
  while (object != null && index < length2) {
    object = object[toKey(path[index++])];
  }
  return index && index == length2 ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function baseSet(object, path, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path = castPath(path, object);
  var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index < length2) {
    var key = toKey(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var stringTag = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}
var OptionsPreProcessors = {
  range: function range2(value) {
    return Math.max(+value, 1);
  },
  "date.highlight": function dateHighlight(args) {
    return castArray(args);
  },
  "subDomain.label": function subDomainLabel(value) {
    return (
      // eslint-disable-next-line
      isString(value) && value !== "" || isFunction(value) ? value : null
    );
  }
};
var Options = function() {
  function Options2() {
    var processors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : OptionsPreProcessors;
    _classCallCheck(this, Options2);
    this.preProcessors = processors;
    this.options = {
      // selector string of the container to append the graph to
      // Accept any string value accepted by document.querySelector or CSS3
      // or an Element object
      itemSelector: OPTIONS_DEFAULT_ITEM_SELECTOR,
      // Number of domain to display on the graph
      range: OPTIONS_DEFAULT_RANGE,
      domain: {
        type: OPTIONS_DEFAULT_DOMAIN_TYPE,
        // Space between each domain, in pixel
        gutter: 4,
        padding: [0, 0, 0, 0],
        // Whether to enable dynamic domain size
        // The width/height on a domain depends on the number of
        // subDomains items count
        dynamicDimension: true,
        // Whether to show most recent date first
        sort: "asc",
        label: {
          // Formatting of the domain label
          // @default: undefined, will use the formatting
          // according to domain type
          // Accept any string accepted by dayjs.format()
          // or a function
          //
          // Refer to https://day.js.org/docs/en/display/format
          // for list of accepted string tokens used by dayjs.format()
          text: void 0,
          // valid: top, right, bottom, left
          position: "bottom",
          // Valid are the direct svg values: start, middle, end
          textAlign: "middle",
          // By default, there is no margin/padding around the label
          offset: {
            x: 0,
            y: 0
          },
          rotate: null,
          // Used only on vertical orientation
          width: 100,
          // Used only on horizontal orientation
          height: 25
        }
      },
      subDomain: {
        type: OPTIONS_DEFAULT_SUBDOMAIN_TYPE,
        // Width of each subDomain cell, in pixel
        width: OPTIONS_DEFAULT_SUBDOMAIN_WIDTH,
        // Height of each subDomain cell, in pixel
        height: OPTIONS_DEFAULT_SUBDOMAIN_HEIGHT,
        // Space between each subDomain cell, in pixel
        gutter: OPTIONS_DEFAULT_SUBDOMAIN_GUTTER,
        // Radius of each subDomain cell, in pixel
        radius: OPTIONS_DEFAULT_SUBDOMAIN_RADIUS,
        // Formatting of the text inside each subDomain cell
        // @default: null, no text
        // Accept any string accepted by dayjs.format()
        // or a function
        //
        // Refer to https://day.js.org/docs/en/display/format
        // for list of accepted string tokens used by dayjs.format()
        label: null,
        color: void 0,
        sort: "asc"
      },
      date: {
        // Start date of the graph
        // @default now
        start: /* @__PURE__ */ new Date(),
        min: void 0,
        max: void 0,
        // List of dates to highlight
        // Valid values:
        // - []: don't highlight anything
        // - an array of Date objects: highlight the specified dates
        highlight: [],
        locale: OPTIONS_DEFAULT_LOCALE,
        timezone: void 0
      },
      // Calendar orientation
      // false: display domains side by side
      // true : display domains one under the other
      verticalOrientation: false,
      data: {
        // Data source
        // URL, where to fetch the original datas
        source: "",
        // Data type
        // Default: json
        type: "json",
        requestInit: {},
        // keyname of the time property
        x: "",
        // keyname of the value property
        y: "",
        // Grouping function of the values
        groupY: "sum",
        defaultValue: null
      },
      scale: void 0,
      // Animation duration, in ms
      animationDuration: OPTIONS_DEFAULT_ANIMATION_DURATION,
      // Theme mode: dark/light
      theme: OPTIONS_DEFAULT_THEME,
      // Internally used options, do not edit not set
      x: {
        domainHorizontalLabelWidth: 0,
        domainVerticalLabelHeight: 0
      }
    };
  }
  _createClass(Options2, [{
    key: "set",
    value: function set$12(key, value) {
      if (!has(this.options, key) || isEqual(get(this.options, key), value)) {
        return false;
      }
      set(this.options, key, has(this.preProcessors, key) ? get(this.preProcessors, key)(value) : value);
      return true;
    }
  }, {
    key: "init",
    value: function init(opts) {
      var _this = this;
      this.options = Object.assign({}, mergeWith$1(this.options, opts, function(_, srcValue) {
        return Array.isArray(srcValue) ? srcValue : void 0;
      }));
      var options = this.options;
      Object.keys(this.preProcessors).forEach(function(key) {
        set(options, key, get(_this.preProcessors, key)(get(options, key)));
      });
      if (typeof options.scale === "undefined") {
        this.initScale();
      }
      options.x.domainVerticalLabelHeight = options.domain.label.height;
      if (options.domain.label.position === "top" || options.domain.label.position === "bottom") {
        options.x.domainHorizontalLabelWidth = 0;
      } else {
        options.x.domainVerticalLabelHeight = 0;
        options.x.domainHorizontalLabelWidth = options.domain.label.width;
      }
      if (options.domain.label.text === null || options.domain.label.text === "") {
        options.x.domainVerticalLabelHeight = 0;
        options.x.domainHorizontalLabelWidth = 0;
      }
    }
  }, {
    key: "initScale",
    value: function initScale() {
      this.options.scale = {
        color: {
          scheme: SCALE_BASE_COLOR_SCHEME,
          type: SCALE_BASE_COLOR_TYPE,
          domain: SCALE_BASE_COLOR_DOMAIN
        }
      };
    }
  }]);
  return Options2;
}();
var anObject$2 = anObject$f;
var regexpFlags$1 = function() {
  var that = anObject$2(this);
  var result = "";
  if (that.hasIndices) result += "d";
  if (that.global) result += "g";
  if (that.ignoreCase) result += "i";
  if (that.multiline) result += "m";
  if (that.dotAll) result += "s";
  if (that.unicode) result += "u";
  if (that.unicodeSets) result += "v";
  if (that.sticky) result += "y";
  return result;
};
var fails$4 = fails$u;
var global$3 = global$n;
var $RegExp$2 = global$3.RegExp;
var UNSUPPORTED_Y$1 = fails$4(function() {
  var re2 = $RegExp$2("a", "y");
  re2.lastIndex = 2;
  return re2.exec("abcd") !== null;
});
var MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4(function() {
  var re2 = $RegExp$2("^r", "gy");
  re2.lastIndex = 2;
  return re2.exec("str") !== null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$1
};
var fails$3 = fails$u;
var global$2 = global$n;
var $RegExp$1 = global$2.RegExp;
var regexpUnsupportedDotAll = fails$3(function() {
  var re2 = $RegExp$1(".", "s");
  return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
});
var fails$2 = fails$u;
var global$1 = global$n;
var $RegExp = global$1.RegExp;
var regexpUnsupportedNcg = fails$2(function() {
  var re2 = $RegExp("(?<a>b)", "g");
  return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
});
var call$2 = functionCall;
var uncurryThis$5 = functionUncurryThis;
var toString$2 = toString$9;
var regexpFlags = regexpFlags$1;
var stickyHelpers = regexpStickyHelpers;
var shared = sharedExports;
var create2 = objectCreate$1;
var getInternalState = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$2 = uncurryThis$5("".charAt);
var indexOf = uncurryThis$5("".indexOf);
var replace$1 = uncurryThis$5("".replace);
var stringSlice$2 = uncurryThis$5("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re1 = /a/;
  var re2 = /b*/g;
  call$2(nativeExec, re1, "a");
  call$2(nativeExec, re2, "a");
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) {
  patchedExec = function exec2(string) {
    var re2 = this;
    var state = getInternalState(re2);
    var str = toString$2(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match2, i, object, group;
    if (raw) {
      raw.lastIndex = re2.lastIndex;
      result = call$2(patchedExec, raw, str);
      re2.lastIndex = raw.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re2.sticky;
    var flags = call$2(regexpFlags, re2);
    var source = re2.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$1(flags, "y", "");
      if (indexOf(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$2(str, re2.lastIndex);
      if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt$2(str, re2.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re2.lastIndex;
    match2 = call$2(nativeExec, sticky ? reCopy : re2, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$2(match2.input, charsAdded);
        match2[0] = stringSlice$2(match2[0], charsAdded);
        match2.index = re2.lastIndex;
        re2.lastIndex += match2[0].length;
      } else re2.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re2.lastIndex = re2.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$2(nativeReplace, match2[0], reCopy, function() {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === void 0) match2[i] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create2(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec$2 = patchedExec;
var $$1 = _export;
var exec = regexpExec$2;
$$1({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
  exec
});
var uncurryThis$4 = functionUncurryThisClause;
var defineBuiltIn = defineBuiltIn$9;
var regexpExec$1 = regexpExec$2;
var fails$1 = fails$u;
var wellKnownSymbol$1 = wellKnownSymbol$m;
var createNonEnumerableProperty = createNonEnumerableProperty$6;
var SPECIES = wellKnownSymbol$1("species");
var RegExpPrototype = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL = wellKnownSymbol$1(KEY);
  var DELEGATES_TO_SYMBOL = !fails$1(function() {
    var O = {};
    O[SYMBOL] = function() {
      return 7;
    };
    return ""[KEY](O) !== 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function() {
    var execCalled = false;
    var re2 = /a/;
    if (KEY === "split") {
      re2 = {};
      re2.constructor = {};
      re2.constructor[SPECIES] = function() {
        return re2;
      };
      re2.flags = "";
      re2[SYMBOL] = /./[SYMBOL];
    }
    re2.exec = function() {
      execCalled = true;
      return null;
    };
    re2[SYMBOL]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = uncurryThis$4(/./[SYMBOL]);
    var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$4(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });
    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }
  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
};
var charAt$1 = stringMultibyte.charAt;
var advanceStringIndex$1 = function(S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
};
var uncurryThis$3 = functionUncurryThis;
var toObject = toObject$a;
var floor = Math.floor;
var charAt = uncurryThis$3("".charAt);
var replace = uncurryThis$3("".replace);
var stringSlice$1 = uncurryThis$3("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$1 = function(matched, str, position2, captures, namedCaptures, replacement2) {
  var tailPos = position2 + matched.length;
  var m = captures.length;
  var symbols2 = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== void 0) {
    namedCaptures = toObject(namedCaptures);
    symbols2 = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement2, symbols2, function(match2, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case "$":
        return "$";
      case "&":
        return matched;
      case "`":
        return stringSlice$1(str, 0, position2);
      case "'":
        return stringSlice$1(str, tailPos);
      case "<":
        capture = namedCaptures[stringSlice$1(ch, 1, -1)];
        break;
      default:
        var n = +ch;
        if (n === 0) return match2;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match2;
          if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match2;
        }
        capture = captures[n - 1];
    }
    return capture === void 0 ? "" : capture;
  });
};
var call$1 = functionCall;
var anObject$1 = anObject$f;
var isCallable$1 = isCallable$o;
var classof = classofRaw$2;
var regexpExec = regexpExec$2;
var $TypeError = TypeError;
var regexpExecAbstract = function(R, S) {
  var exec2 = R.exec;
  if (isCallable$1(exec2)) {
    var result = call$1(exec2, R, S);
    if (result !== null) anObject$1(result);
    return result;
  }
  if (classof(R) === "RegExp") return call$1(regexpExec, R, S);
  throw new $TypeError("RegExp#exec called on incompatible receiver");
};
var apply = functionApply;
var call = functionCall;
var uncurryThis$2 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var fails = fails$u;
var anObject = anObject$f;
var isCallable = isCallable$o;
var isNullOrUndefined = isNullOrUndefined$8;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var toLength = toLength$3;
var toString$1 = toString$9;
var requireObjectCoercible$1 = requireObjectCoercible$7;
var advanceStringIndex = advanceStringIndex$1;
var getMethod = getMethod$4;
var getSubstitution = getSubstitution$1;
var regExpExec$1 = regexpExecAbstract;
var wellKnownSymbol = wellKnownSymbol$m;
var REPLACE = wellKnownSymbol("replace");
var max2 = Math.max;
var min2 = Math.min;
var concat2 = uncurryThis$2([].concat);
var push = uncurryThis$2([].push);
var stringIndexOf$1 = uncurryThis$2("".indexOf);
var stringSlice = uncurryThis$2("".slice);
var maybeToString = function(it) {
  return it === void 0 ? it : String(it);
};
var REPLACE_KEEPS_$0 = function() {
  return "a".replace(/./, "$0") === "$0";
}();
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
  if (/./[REPLACE]) {
    return /./[REPLACE]("a", "$0") === "";
  }
  return false;
}();
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
  var re2 = /./;
  re2.exec = function() {
    var result = [];
    result.groups = { a: "7" };
    return result;
  };
  return "".replace(re2, "$<a>") !== "7";
});
fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace2, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace2(searchValue, replaceValue) {
      var O = requireObjectCoercible$1(this);
      var replacer = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
      return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace2, toString$1(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(string, replaceValue) {
      var rx = anObject(this);
      var S = toString$1(string);
      if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
        var res = maybeCallNative(nativeReplace2, rx, S, replaceValue);
        if (res.done) return res.value;
      }
      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString$1(replaceValue);
      var global2 = rx.global;
      var fullUnicode;
      if (global2) {
        fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      var result;
      while (true) {
        result = regExpExec$1(rx, S);
        if (result === null) break;
        push(results, result);
        if (!global2) break;
        var matchStr = toString$1(result[0]);
        if (matchStr === "") rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = "";
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = toString$1(result[0]);
        var position2 = max2(min2(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        var replacement2;
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat2([matched], captures, position2, S);
          if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
          replacement2 = toString$1(apply(replaceValue, void 0, replacerArgs));
        } else {
          replacement2 = getSubstitution(matched, S, position2, captures, namedCaptures, replaceValue);
        }
        if (position2 >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position2) + replacement2;
          nextSourcePosition = position2 + matched.length;
        }
      }
      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
var _DataFetcher_instances;
var _DataFetcher_fetch;
var DataFetcher = function() {
  function DataFetcher2(calendar) {
    _classCallCheck(this, DataFetcher2);
    _DataFetcher_instances.add(this);
    this.calendar = calendar;
  }
  _createClass(DataFetcher2, [{
    key: "getDatas",
    value: function getDatas(source, startTimestamp, endTimestamp) {
      return __awaiter(this, void 0, void 0, _regeneratorRuntime().mark(function _callee() {
        var d;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof source === "string" && source.length > 0)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", __classPrivateFieldGet(this, _DataFetcher_instances, "m", _DataFetcher_fetch).call(this, source, startTimestamp, endTimestamp));
            case 2:
              d = [];
              if (Array.isArray(source)) {
                d = source;
              }
              return _context.abrupt("return", new Promise(function(resolve2) {
                resolve2(d);
              }));
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "parseURI",
    value: function parseURI(str, startTimestamp, endTimestamp) {
      var _this = this;
      var newUri = str.replace(/\{\{start=(.*?)\}\}/g, function(_, format) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          _this.calendar.dateHelper.date(startTimestamp).format(format)
        );
      });
      newUri = newUri.replace(/\{\{end=(.*?)\}\}/g, function(_, format) {
        return (
          // eslint-disable-next-line implicit-arrow-linebreak
          _this.calendar.dateHelper.date(endTimestamp).format(format)
        );
      });
      return newUri;
    }
  }]);
  return DataFetcher2;
}();
_DataFetcher_instances = /* @__PURE__ */ new WeakSet(), _DataFetcher_fetch = function _DataFetcher_fetch2(source, startTimestamp, endTimestamp) {
  var _this$calendar$option = this.calendar.options.options.data, type = _this$calendar$option.type, requestInit = _this$calendar$option.requestInit;
  var url = this.parseURI(source, startTimestamp, endTimestamp);
  switch (type) {
    case "json":
      return json_default(url, requestInit);
    case "csv":
      return csv(url, requestInit);
    case "tsv":
      return dsv("	", url, requestInit);
    case "txt":
      return text_default(url, requestInit);
    default:
      return new Promise(function(resolve2) {
        resolve2([]);
      });
  }
};
var DESCRIPTORS = descriptors;
var FUNCTION_NAME_EXISTS = functionName.EXISTS;
var uncurryThis$1 = functionUncurryThis;
var defineBuiltInAccessor = defineBuiltInAccessor$3;
var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis$1(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = uncurryThis$1(nameRE.exec);
var NAME = "name";
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
  defineBuiltInAccessor(FunctionPrototype, NAME, {
    configurable: true,
    get: function() {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error) {
        return "";
      }
    }
  });
}
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t, e) {
    module2.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date()) return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return void 0 === t2;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t2) {
      return t2 instanceof _ || !(!t2 || !t2[p]);
    }, w = function t2(e2, n2, r2) {
      var i2;
      if (!e2) return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1) return t2(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t2, e2) {
      if (S(t2)) return t2.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t2, e2) {
      return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (null === e2) return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2)) return /* @__PURE__ */ new Date();
          if (e2 instanceof Date) return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = O(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return O(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < O(t2);
      }, m2.$g = function(t2, e2, n2) {
        return b.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $3 = function(t3, e3) {
          return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $3(v2 + "Hours", 0);
          case u:
            return $3(v2 + "Minutes", 1);
          case s:
            return $3(v2 + "Seconds", 2);
          case i:
            return $3(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $3 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else l2 && this.$d[l2]($3);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[b.p(t2)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $3 = b.p(f2), y2 = function(t2) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($3 === c) return this.set(c, this.$M + r2);
        if ($3 === h) return this.set(h, this.$y + r2);
        if ($3 === a) return y2(1);
        if ($3 === o) return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid()) return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return b.s(s2 % 12 || 12, t3, "0");
        }, $3 = f2 || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h2(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h2(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $3(s2, u2, true);
              case "A":
                return $3(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $3, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h:
            $3 = D2() / 12;
            break;
          case c:
            $3 = D2();
            break;
          case f:
            $3 = D2() / 3;
            break;
          case o:
            $3 = (g2 - v2) / 6048e5;
            break;
          case a:
            $3 = (g2 - v2) / 864e5;
            break;
          case u:
            $3 = g2 / n;
            break;
          case s:
            $3 = g2 / e;
            break;
          case i:
            $3 = g2 / t;
            break;
          default:
            $3 = g2;
        }
        return l2 ? $3 : b.a($3);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2) return this.$L;
        var n2 = this.clone(), r2 = w(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
      k[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), O.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, O), t2.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
      return O(1e3 * t2);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
var dayjs = getDefaultExportFromCjs(dayjs_minExports);
var weekOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    var e = "week", t = "year";
    return function(i, n, r) {
      var f = n.prototype;
      f.week = function(i2) {
        if (void 0 === i2 && (i2 = null), null !== i2) return this.add(7 * (i2 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (11 === this.month() && this.date() > 25) {
          var f2 = r(this).startOf(t).add(1, t).date(n2), s = r(this).endOf(e);
          if (f2.isBefore(s)) return 1;
        }
        var a = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, true);
        return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
      }, f.weeks = function(e2) {
        return void 0 === e2 && (e2 = null), this.week(e2);
      };
    };
  });
})(weekOfYear$1);
var weekOfYearExports = weekOfYear$1.exports;
var weekOfYear = getDefaultExportFromCjs(weekOfYearExports);
var dayOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, n) {
      t.prototype.dayOfYear = function(e2) {
        var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
        return null == e2 ? t2 : this.add(e2 - t2, "day");
      };
    };
  });
})(dayOfYear$1);
var dayOfYearExports = dayOfYear$1.exports;
var dayOfYear = getDefaultExportFromCjs(dayOfYearExports);
var weekday$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.weekday = function(e2) {
        var t2 = this.$locale().weekStart || 0, i = this.$W, n = (i < t2 ? i + 7 : i) - t2;
        return this.$utils().u(e2) ? n : this.subtract(n, "day").add(e2, "day");
      };
    };
  });
})(weekday$1);
var weekdayExports = weekday$1.exports;
var weekday = getDefaultExportFromCjs(weekdayExports);
var minMax$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, n) {
    module2.exports = n();
  }(commonjsGlobal, function() {
    return function(e, n, t) {
      var i = function(e2, n2) {
        if (!n2 || !n2.length || 1 === n2.length && !n2[0] || 1 === n2.length && Array.isArray(n2[0]) && !n2[0].length) return null;
        var t2;
        1 === n2.length && n2[0].length > 0 && (n2 = n2[0]);
        t2 = (n2 = n2.filter(function(e3) {
          return e3;
        }))[0];
        for (var i2 = 1; i2 < n2.length; i2 += 1) n2[i2].isValid() && !n2[i2][e2](t2) || (t2 = n2[i2]);
        return t2;
      };
      t.max = function() {
        var e2 = [].slice.call(arguments, 0);
        return i("isAfter", e2);
      }, t.min = function() {
        var e2 = [].slice.call(arguments, 0);
        return i("isBefore", e2);
      };
    };
  });
})(minMax$1);
var minMaxExports = minMax$1.exports;
var minMax = getDefaultExportFromCjs(minMaxExports);
var isoWeeksInYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, n) {
    module2.exports = n();
  }(commonjsGlobal, function() {
    return function(e, n) {
      n.prototype.isoWeeksInYear = function() {
        var e2 = this.isLeapYear(), n2 = this.endOf("y").day();
        return 4 === n2 || e2 && 5 === n2 ? 53 : 52;
      };
    };
  });
})(isoWeeksInYear$1);
var isoWeeksInYearExports = isoWeeksInYear$1.exports;
var isoWeeksInYear = getDefaultExportFromCjs(isoWeeksInYearExports);
var isoWeek$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    var e = "day";
    return function(t, i, s) {
      var a = function(t2) {
        return t2.add(4 - t2.isoWeekday(), e);
      }, d = i.prototype;
      d.isoWeekYear = function() {
        return a(this).year();
      }, d.isoWeek = function(t2) {
        if (!this.$utils().u(t2)) return this.add(7 * (t2 - this.isoWeek()), e);
        var i2, d2, n2, o, r = a(this), u = (i2 = this.isoWeekYear(), d2 = this.$u, n2 = (d2 ? s.utc : s)().year(i2).startOf("year"), o = 4 - n2.isoWeekday(), n2.isoWeekday() > 4 && (o += 7), n2.add(o, e));
        return r.diff(u, "week") + 1;
      }, d.isoWeekday = function(e2) {
        return this.$utils().u(e2) ? this.day() || 7 : this.day(this.day() % 7 ? e2 : e2 - 7);
      };
      var n = d.startOf;
      d.startOf = function(e2, t2) {
        var i2 = this.$utils(), s2 = !!i2.u(t2) || t2;
        return "isoweek" === i2.p(e2) ? s2 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n.bind(this)(e2, t2);
      };
    };
  });
})(isoWeek$1);
var isoWeekExports = isoWeek$1.exports;
var isoWeek = getDefaultExportFromCjs(isoWeekExports);
var isLeapYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.isLeapYear = function() {
        return this.$y % 4 == 0 && this.$y % 100 != 0 || this.$y % 400 == 0;
      };
    };
  });
})(isLeapYear$1);
var isLeapYearExports = isLeapYear$1.exports;
var isLeapYear = getDefaultExportFromCjs(isLeapYearExports);
var advancedFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      var r = t.prototype, n = r.format;
      r.format = function(e2) {
        var t2 = this, r2 = this.$locale();
        if (!this.isValid()) return n.bind(this)(e2);
        var s = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
          switch (e3) {
            case "Q":
              return Math.ceil((t2.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t2.$D);
            case "gggg":
              return t2.weekYear();
            case "GGGG":
              return t2.isoWeekYear();
            case "wo":
              return r2.ordinal(t2.week(), "W");
            case "w":
            case "ww":
              return s.s(t2.week(), "w" === e3 ? 1 : 2, "0");
            case "W":
            case "WW":
              return s.s(t2.isoWeek(), "W" === e3 ? 1 : 2, "0");
            case "k":
            case "kk":
              return s.s(String(0 === t2.$H ? 24 : t2.$H), "k" === e3 ? 1 : 2, "0");
            case "X":
              return Math.floor(t2.$d.getTime() / 1e3);
            case "x":
              return t2.$d.getTime();
            case "z":
              return "[" + t2.offsetName() + "]";
            case "zzz":
              return "[" + t2.offsetName("long") + "]";
            default:
              return e3;
          }
        });
        return n.bind(this)(a);
      };
    };
  });
})(advancedFormat$1);
var advancedFormatExports = advancedFormat$1.exports;
var advancedFormat = getDefaultExportFromCjs(advancedFormatExports);
var utc$1 = { exports: {} };
(function(module2, exports2) {
  !function(t, i) {
    module2.exports = i();
  }(commonjsGlobal, function() {
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
      var u = f.prototype;
      n.utc = function(t2) {
        var i2 = { date: t2, utc: true, args: arguments };
        return new f(i2);
      }, u.utc = function(i2) {
        var e2 = n(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e2.add(this.utcOffset(), t) : e2;
      }, u.local = function() {
        return n(this.toDate(), { locale: this.$L, utc: false });
      };
      var o = u.parse;
      u.parse = function(t2) {
        t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
      };
      var r = u.init;
      u.init = function() {
        if (this.$u) {
          var t2 = this.$d;
          this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
        } else r.call(this);
      };
      var a = u.utcOffset;
      u.utcOffset = function(s2, f2) {
        var n2 = this.$utils().u;
        if (n2(s2)) return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
        if ("string" == typeof s2 && (s2 = function(t2) {
          void 0 === t2 && (t2 = "");
          var s3 = t2.match(i);
          if (!s3) return null;
          var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
          return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
        }(s2), null === s2)) return this;
        var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f2) return o2.$offset = u2, o2.$u = 0 === s2, o2;
        if (0 !== s2) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
        } else o2 = this.utc();
        return o2;
      };
      var h = u.format;
      u.format = function(t2) {
        var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i2);
      }, u.valueOf = function() {
        var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * t2;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var l = u.toDate;
      u.toDate = function(t2) {
        return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
      };
      var c = u.diff;
      u.diff = function(t2, i2, e2) {
        if (t2 && this.$u === t2.$u) return c.call(this, t2, i2, e2);
        var s2 = this.local(), f2 = n(t2).local();
        return c.call(s2, f2, i2, e2);
      };
    };
  });
})(utc$1);
var utcExports = utc$1.exports;
var utc = getDefaultExportFromCjs(utcExports);
var timezone$1 = { exports: {} };
(function(module2, exports2) {
  !function(t, e) {
    module2.exports = e();
  }(commonjsGlobal, function() {
    var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
    return function(n, i, o) {
      var r, a = function(t2, n2, i2) {
        void 0 === i2 && (i2 = {});
        var o2 = new Date(t2), r2 = function(t3, n3) {
          void 0 === n3 && (n3 = {});
          var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
          return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
        }(n2, i2);
        return r2.formatToParts(o2);
      }, u = function(e2, n2) {
        for (var i2 = a(e2, n2), r2 = [], u2 = 0; u2 < i2.length; u2 += 1) {
          var f2 = i2[u2], s2 = f2.type, m = f2.value, c = t[s2];
          c >= 0 && (r2[c] = parseInt(m, 10));
        }
        var d = r2[3], l = 24 === d ? 0 : d, h = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", v = +e2;
        return (o.utc(h).valueOf() - (v -= v % 1e3)) / 6e4;
      }, f = i.prototype;
      f.tz = function(t2, e2) {
        void 0 === t2 && (t2 = r);
        var n2 = this.utcOffset(), i2 = this.toDate(), a2 = i2.toLocaleString("en-US", { timeZone: t2 }), u2 = Math.round((i2 - new Date(a2)) / 1e3 / 60), f2 = o(a2, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(15 * -Math.round(i2.getTimezoneOffset() / 15) - u2, true);
        if (e2) {
          var s2 = f2.utcOffset();
          f2 = f2.add(n2 - s2, "minute");
        }
        return f2.$x.$timezone = t2, f2;
      }, f.offsetName = function(t2) {
        var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, { timeZoneName: t2 }).find(function(t3) {
          return "timezonename" === t3.type.toLowerCase();
        });
        return n2 && n2.value;
      };
      var s = f.startOf;
      f.startOf = function(t2, e2) {
        if (!this.$x || !this.$x.$timezone) return s.call(this, t2, e2);
        var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
        return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
      }, o.tz = function(t2, e2, n2) {
        var i2 = n2 && e2, a2 = n2 || e2 || r, f2 = u(+o(), a2);
        if ("string" != typeof t2) return o(t2).tz(a2);
        var s2 = function(t3, e3, n3) {
          var i3 = t3 - 60 * e3 * 1e3, o2 = u(i3, n3);
          if (e3 === o2) return [i3, e3];
          var r2 = u(i3 -= 60 * (o2 - e3) * 1e3, n3);
          return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1e3, Math.max(o2, r2)];
        }(o.utc(t2, i2).valueOf(), f2, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
        return d.$x.$timezone = a2, d;
      }, o.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o.tz.setDefault = function(t2) {
        r = t2;
      };
    };
  });
})(timezone$1);
var timezoneExports = timezone$1.exports;
var timezone = getDefaultExportFromCjs(timezoneExports);
var localeData$1 = { exports: {} };
(function(module2, exports2) {
  !function(n, e) {
    module2.exports = e();
  }(commonjsGlobal, function() {
    return function(n, e, t) {
      var r = e.prototype, o = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u = function(n2, e2, t2, r2, u2) {
        var i2 = n2.name ? n2 : n2.$locale(), a2 = o(i2[e2]), s2 = o(i2[t2]), f = a2 || s2.map(function(n3) {
          return n3.slice(0, r2);
        });
        if (!u2) return f;
        var d = i2.weekStart;
        return f.map(function(n3, e3) {
          return f[(e3 + (d || 0)) % 7];
        });
      }, i = function() {
        return t.Ls[t.locale()];
      }, a = function(n2, e2) {
        return n2.formats[e2] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
            return e3 || t2.slice(1);
          });
        }(n2.formats[e2.toUpperCase()]);
      }, s = function() {
        var n2 = this;
        return { months: function(e2) {
          return e2 ? e2.format("MMMM") : u(n2, "months");
        }, monthsShort: function(e2) {
          return e2 ? e2.format("MMM") : u(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e2) {
          return e2 ? e2.format("dddd") : u(n2, "weekdays");
        }, weekdaysMin: function(e2) {
          return e2 ? e2.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e2) {
          return e2 ? e2.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e2) {
          return a(n2.$locale(), e2);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return s.bind(this)();
      }, t.localeData = function() {
        var n2 = i();
        return { firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e2) {
          return a(n2, e2);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal };
      }, t.months = function() {
        return u(i(), "months");
      }, t.monthsShort = function() {
        return u(i(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u(i(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u(i(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u(i(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
})(localeData$1);
var localeDataExports = localeData$1.exports;
var localeData = getDefaultExportFromCjs(localeDataExports);
var localizedFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(t, o, n) {
      var r = o.prototype, i = r.format;
      n.en.formats = e, r.format = function(t2) {
        void 0 === t2 && (t2 = "YYYY-MM-DDTHH:mm:ssZ");
        var o2 = this.$locale().formats, n2 = function(t3, o3) {
          return t3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t4, n3, r2) {
            var i2 = r2 && r2.toUpperCase();
            return n3 || o3[r2] || e[r2] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t5, o4) {
              return t5 || o4.slice(1);
            });
          });
        }(t2, void 0 === o2 ? {} : o2);
        return i.call(this, n2);
      };
    };
  });
})(localizedFormat$1);
var localizedFormatExports = localizedFormat$1.exports;
var localizedFormat = getDefaultExportFromCjs(localizedFormatExports);
var updateLocale$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, n) {
    module2.exports = n();
  }(commonjsGlobal, function() {
    return function(e, n, t) {
      t.updateLocale = function(e2, n2) {
        var o = t.Ls[e2];
        if (o) return (n2 ? Object.keys(n2) : []).forEach(function(e3) {
          o[e3] = n2[e3];
        }), o;
      };
    };
  });
})(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
var updateLocale = getDefaultExportFromCjs(updateLocaleExports);
dayjs.extend(weekOfYear);
dayjs.extend(isoWeeksInYear);
dayjs.extend(isoWeek);
dayjs.extend(isLeapYear);
dayjs.extend(dayOfYear);
dayjs.extend(weekday);
dayjs.extend(minMax);
dayjs.extend(advancedFormat);
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(localeData);
dayjs.extend(localizedFormat);
dayjs.extend(updateLocale);
var DEFAULT_LOCALE = "en";
var DateHelper = function() {
  function DateHelper2() {
    _classCallCheck(this, DateHelper2);
    var _a;
    this.locale = DEFAULT_LOCALE;
    this.timezone = dayjs.tz.guess();
    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") {
      (_a = window).dayjs || (_a.dayjs = dayjs);
    }
  }
  _createClass(DateHelper2, [{
    key: "setup",
    value: function setup(_ref) {
      var options = _ref.options;
      return __awaiter(this, void 0, void 0, _regeneratorRuntime().mark(function _callee() {
        var userLocale, locale;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.timezone = options.date.timezone || dayjs.tz.guess();
              userLocale = options.date.locale;
              if (!(typeof userLocale === "string" && userLocale !== DEFAULT_LOCALE)) {
                _context.next = 17;
                break;
              }
              if (!((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object")) {
                _context.next = 12;
                break;
              }
              _context.t0 = window["dayjs_locale_".concat(userLocale)];
              if (_context.t0) {
                _context.next = 9;
                break;
              }
              _context.next = 8;
              return this.loadBrowserLocale(userLocale);
            case 8:
              _context.t0 = _context.sent;
            case 9:
              locale = _context.t0;
              _context.next = 15;
              break;
            case 12:
              _context.next = 14;
              return this.loadNodeLocale(userLocale);
            case 14:
              locale = _context.sent;
            case 15:
              dayjs.locale(userLocale);
              this.locale = locale;
            case 17:
              if (_typeof(userLocale) === "object") {
                if (userLocale.hasOwnProperty("name")) {
                  dayjs.locale(userLocale.name, userLocale);
                  this.locale = userLocale;
                } else {
                  this.locale = dayjs.updateLocale(DEFAULT_LOCALE, userLocale);
                }
              }
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "extend",
    value: function extend(dayjsPlugin) {
      return dayjs.extend(dayjsPlugin);
    }
    /**
     * Return the week number, relative to its month
     *
     * @param  {number|Date} d Date or timestamp in milliseconds
     * @returns {number} The week number, relative to the month [0-5]
     */
  }, {
    key: "getMonthWeekNumber",
    value: function getMonthWeekNumber(d) {
      var dayjsDate = this.date(d);
      var date = dayjsDate.startOf("day");
      var endOfWeek = dayjsDate.startOf("month").endOf("week");
      if (date <= endOfWeek) {
        return 1;
      }
      return Math.ceil(date.diff(endOfWeek, "weeks", true)) + 1;
    }
    /**
     * Return the number of weeks in the given month
     *
     * As there is no fixed standard to specify which month a partial week should
     * belongs to, the ISO week date standard is used, where:
     * - the first week of the month should have at least 4 days
     *
     *  @see https://en.wikipedia.org/wiki/ISO_week_date
     *
     * @param  {Timestamp | dayjs.Dayjs} d Datejs object or timestamp
     * @return {number}         The number of weeks
     */
  }, {
    key: "getWeeksCountInMonth",
    value: function getWeeksCountInMonth(d) {
      var pivotDate = this.date(d);
      return this.getLastWeekOfMonth(pivotDate).diff(this.getFirstWeekOfMonth(pivotDate), "week") + 1;
    }
    /**
     * Return the start of the first week of the month
     *
     * @see getWeeksCountInMonth() about standard warning
     * @return {dayjs.Dayjs} A dayjs object representing the start of the
     * first week
     */
  }, {
    key: "getFirstWeekOfMonth",
    value: function getFirstWeekOfMonth(d) {
      var startOfMonth = this.date(d).startOf("month");
      var startOfFirstWeek = startOfMonth.startOf("week");
      if (startOfMonth.weekday() > 4) {
        startOfFirstWeek = startOfFirstWeek.add(1, "week");
      }
      return startOfFirstWeek;
    }
    /**
     * Return the end of the last week of the month
     *
     * @see getWeeksCountInMonth() about standard warning
     * @return {dayjs.Dayjs} A dayjs object representing the end of the last week
     */
  }, {
    key: "getLastWeekOfMonth",
    value: function getLastWeekOfMonth(d) {
      var endOfMonth = this.date(d).endOf("month");
      var endOfLastWeek = endOfMonth.endOf("week");
      if (endOfMonth.weekday() < 4) {
        endOfLastWeek = endOfLastWeek.subtract(1, "week");
      }
      return endOfLastWeek;
    }
  }, {
    key: "date",
    value: function date() {
      var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
      if (dayjs.isDayjs(d)) {
        return d;
      }
      return dayjs(d).tz(this.timezone).utcOffset(0).locale(this.locale);
    }
  }, {
    key: "format",
    value: function format(timestamp, formatter) {
      if (typeof formatter === "function") {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return formatter.apply(void 0, [timestamp].concat(args));
      }
      if (typeof formatter === "string") {
        return this.date(timestamp).format(formatter);
      }
      return null;
    }
    /**
     * Return an array of time interval
     *
     * @param  {number|Date} date A random date included in the wanted interval
     * @param  {number|Date} range Length of the wanted interval, or a stop date.
     * @param  {boolean} range Whether the end date should be excluded
     *                         from the result
     * @returns {Array<number>} Array of unix timestamp, in milliseconds
     */
  }, {
    key: "intervals",
    value: function intervals(interval, date, range3) {
      var excludeEnd = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var start = this.date(date);
      var end;
      if (typeof range3 === "number") {
        end = start.add(range3, interval);
      } else if (dayjs.isDayjs(range3)) {
        end = range3;
      } else {
        end = this.date(range3);
      }
      start = start.startOf(interval);
      end = end.startOf(interval);
      var pivot = dayjs.min(start, end);
      end = dayjs.max(start, end);
      var result = [];
      if (!excludeEnd) {
        end = end.add(1, "second");
      }
      do {
        result.push(+pivot);
        pivot = pivot.add(1, interval);
      } while (pivot < end);
      return result;
    }
    // this function will work cross-browser for loading scripts asynchronously
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "loadBrowserLocale",
    value: function loadBrowserLocale(userLocale) {
      return new Promise(function(resolve2, reject2) {
        var s = document.createElement("script");
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://cdn.jsdelivr.net/npm/dayjs@1/locale/".concat(userLocale, ".js");
        s.onerror = function(err) {
          reject2(err);
        };
        s.onload = function() {
          resolve2(window["dayjs_locale_".concat(userLocale)]);
        };
        document.head.appendChild(s);
      });
    }
    // eslint-disable-next-line class-methods-use-this
  }, {
    key: "loadNodeLocale",
    value: function loadNodeLocale(userLocale) {
      return import("dayjs/locale/".concat(userLocale, ".js"));
    }
  }]);
  return DateHelper2;
}();
var $ = _export;
var uncurryThis = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$7;
var toString3 = toString$9;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis("".indexOf);
$({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf(
      toString3(requireObjectCoercible(this)),
      toString3(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var ALLOWED_DATA_TYPES = ["json", "csv", "tsv", "txt"];
function validate(templateCollection, _ref) {
  var domain = _ref.domain, subDomain = _ref.subDomain, data2 = _ref.data;
  var domainType = domain.type;
  var subDomainType = subDomain.type;
  if (!templateCollection.has(domainType)) {
    throw new Error("'".concat(domainType, "' is not a valid domain type'"));
  }
  if (!templateCollection.has(subDomainType)) {
    throw new Error("'".concat(subDomainType, "' is not a valid subDomain type'"));
  }
  if (data2.type && !ALLOWED_DATA_TYPES.includes(data2.type)) {
    throw new Error("The data type '".concat(data2.type, "' is not valid data type"));
  }
  if (!(templateCollection.get(subDomainType).allowedDomainType || []).includes(domainType)) {
    throw new Error("The subDomain.type '".concat(subDomainType, "' can not be used together ") + "with the domain type ".concat(domainType));
  }
  return true;
}
var collection = collection$3;
var collectionStrong = collectionStrong$2;
collection("Set", function(init) {
  return function Set2() {
    return init(this, arguments.length ? arguments[0] : void 0);
  };
}, collectionStrong);
function createPlugin(Creator, calendar) {
  return new Creator(calendar);
}
function extractPluginName(PluginClass, options) {
  return "".concat(new PluginClass().name).concat((options === null || options === void 0 ? void 0 : options.key) || "");
}
var PluginManager = function() {
  function PluginManager2(calendar) {
    _classCallCheck(this, PluginManager2);
    this.calendar = calendar;
    this.settings = /* @__PURE__ */ new Map();
    this.plugins = /* @__PURE__ */ new Map();
    this.pendingPaint = /* @__PURE__ */ new Set();
  }
  _createClass(PluginManager2, [{
    key: "add",
    value: function add(plugins) {
      var _this = this;
      plugins.forEach(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), PluginClass = _ref2[0], pluginOptions = _ref2[1];
        var name = extractPluginName(PluginClass, pluginOptions);
        var existingPlugin = _this.plugins.get(name);
        if (existingPlugin && _this.settings.get(name) && isEqual(_this.settings.get(name).options, pluginOptions)) {
          return;
        }
        _this.settings.set(name, {
          options: pluginOptions,
          dirty: true
        });
        if (!_this.plugins.has(name)) {
          _this.plugins.set(name, createPlugin(PluginClass, _this.calendar));
        }
        _this.pendingPaint.add(_this.plugins.get(name));
      });
    }
  }, {
    key: "setupAll",
    value: function setupAll() {
      var _this2 = this;
      this.plugins.forEach(function(pluginInstance, name) {
        var settings = _this2.settings.get(name);
        if (typeof settings !== "undefined") {
          if (settings.dirty) {
            pluginInstance.setup(settings.options);
            settings.dirty = false;
            _this2.settings.set(name, settings);
          }
        }
      });
    }
  }, {
    key: "paintAll",
    value: function paintAll() {
      return Array.from(this.pendingPaint.values()).map(function(p) {
        return p.paint();
      });
    }
  }, {
    key: "destroyAll",
    value: function destroyAll() {
      return this.allPlugins().map(function(p) {
        return p.destroy();
      });
    }
  }, {
    key: "getFromPosition",
    value: function getFromPosition(position2) {
      return this.allPlugins().filter(function(plugin) {
        var _a;
        return ((_a = plugin.options) === null || _a === void 0 ? void 0 : _a.position) === position2;
      });
    }
  }, {
    key: "getHeightFromPosition",
    value: function getHeightFromPosition(position2) {
      return this.getFromPosition(position2).map(function(d) {
        return d.options.dimensions.height;
      }).reduce(function(a, b) {
        return a + b;
      }, 0);
    }
  }, {
    key: "getWidthFromPosition",
    value: function getWidthFromPosition(position2) {
      return this.getFromPosition(position2).map(function(d) {
        return d.options.dimensions.width;
      }).reduce(function(a, b) {
        return a + b;
      }, 0);
    }
  }, {
    key: "allPlugins",
    value: function allPlugins() {
      return Array.from(this.plugins.values());
    }
  }]);
  return PluginManager2;
}();
var VERSION = "4.2.4";
var minuteTemplate = function minuteTemplate2(DateHelper2) {
  var COLUMNS_COUNT = 10;
  var ROWS_COUNT = 6;
  var ALLOWED_DOMAIN_TYPE = ["day", "hour"];
  return {
    name: "minute",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return COLUMNS_COUNT;
    },
    columnsCount: function columnsCount() {
      return ROWS_COUNT;
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        DateHelper2.intervals("minute", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts, index) {
          return {
            t: ts,
            x: Math.floor(index / COLUMNS_COUNT),
            y: index % COLUMNS_COUNT
          };
        })
      );
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("minute").valueOf();
    }
  };
};
var hourTemplate = function hourTemplate2(DateHelper2, _ref) {
  var domain = _ref.domain;
  var TOTAL_ITEMS = 24;
  var ROWS_COUNT = 6;
  var ALLOWED_DOMAIN_TYPE = ["month", "week", "day"];
  return {
    name: "hour",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return ROWS_COUNT;
    },
    columnsCount: function columnsCount(ts) {
      switch (domain.type) {
        case "week":
          return TOTAL_ITEMS / ROWS_COUNT * 7;
        case "month":
          return TOTAL_ITEMS / ROWS_COUNT * (domain.dynamicDimension ? DateHelper2.date(ts).daysInMonth() : 31);
        case "day":
        default:
          return TOTAL_ITEMS / ROWS_COUNT;
      }
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        DateHelper2.intervals("hour", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
          var date = DateHelper2.date(ts);
          var hour = date.hour();
          var monthDate = date.date();
          var baseX = Math.floor(hour / ROWS_COUNT);
          var columnOffset = TOTAL_ITEMS / ROWS_COUNT;
          if (domain.type === "month") {
            baseX += (monthDate - 1) * columnOffset;
          }
          if (domain.type === "week") {
            baseX += +date.format("d") * columnOffset;
          }
          return {
            t: ts,
            x: baseX,
            y: Math.floor(hour % ROWS_COUNT)
          };
        })
      );
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("hour").valueOf();
    }
  };
};
var dayTemplate$2 = function dayTemplate(DateHelper2, _ref) {
  var domain = _ref.domain, verticalOrientation = _ref.verticalOrientation;
  var ROWS_COUNT = 7;
  var ALLOWED_DOMAIN_TYPE = ["year", "month", "week"];
  return {
    name: "day",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return domain.type === "week" ? 1 : ROWS_COUNT;
    },
    columnsCount: function columnsCount(ts) {
      switch (domain.type) {
        case "month":
          return Math.ceil(domain.dynamicDimension && !verticalOrientation ? DateHelper2.getMonthWeekNumber(DateHelper2.date(ts).endOf("month")) : 6);
        case "year":
          return Math.ceil(domain.dynamicDimension ? DateHelper2.date(ts).endOf("year").dayOfYear() / ROWS_COUNT : 54);
        case "week":
        default:
          return ROWS_COUNT;
      }
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      var weekNumber = 0;
      var x = -1;
      return DateHelper2.intervals("day", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
        var date = DateHelper2.date(ts);
        switch (domain.type) {
          case "month":
            x = DateHelper2.getMonthWeekNumber(ts) - 1;
            break;
          case "year":
            if (weekNumber !== date.week()) {
              weekNumber = date.week();
              x += 1;
            }
            break;
          case "week":
            x = date.weekday();
            break;
        }
        return {
          t: ts,
          x,
          y: domain.type === "week" ? 0 : date.weekday()
        };
      });
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("day").valueOf();
    }
  };
};
var dayTemplate$1 = function dayTemplate2(DateHelper2, _ref) {
  var domain = _ref.domain, verticalOrientation = _ref.verticalOrientation;
  var COLUMNS_COUNT = 7;
  var ALLOWED_DOMAIN_TYPE = ["year", "month", "week"];
  return {
    name: "xDay",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount(ts) {
      switch (domain.type) {
        case "month":
          return Math.ceil(domain.dynamicDimension && !verticalOrientation ? DateHelper2.getMonthWeekNumber(DateHelper2.date(ts).endOf("month")) : 6);
        case "year":
          return Math.ceil(domain.dynamicDimension ? DateHelper2.date(ts).endOf("year").dayOfYear() / COLUMNS_COUNT : 54);
        case "week":
        default:
          return COLUMNS_COUNT;
      }
    },
    columnsCount: function columnsCount() {
      if (domain.type === "week") {
        return 1;
      }
      return COLUMNS_COUNT;
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        DateHelper2.intervals("day", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
          var date = DateHelper2.date(ts);
          var endWeekNumber = date.endOf("year").week();
          var x = 0;
          switch (domain.type) {
            case "month":
              x = DateHelper2.getMonthWeekNumber(ts) - 1;
              break;
            case "year":
              if (endWeekNumber === 1 && date.week() === endWeekNumber) {
                x = date.subtract(1, "week").week() + 1;
              }
              x = date.week() - 1;
              break;
            case "week":
              x = date.weekday();
              break;
          }
          return {
            t: ts,
            y: x,
            x: domain.type === "week" ? 0 : date.weekday()
          };
        })
      );
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("day").valueOf();
    }
  };
};
var dayTemplate3 = function dayTemplate4(DateHelper2) {
  var ROWS_COUNT = 7;
  var ALLOWED_DOMAIN_TYPE = ["month"];
  return {
    name: "ghDay",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return ROWS_COUNT;
    },
    columnsCount: function columnsCount(ts) {
      return DateHelper2.getWeeksCountInMonth(ts);
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      var clampStart = DateHelper2.getFirstWeekOfMonth(startTimestamp);
      var clampEnd = DateHelper2.getFirstWeekOfMonth(endTimestamp);
      var x = -1;
      var pivotDay = clampStart.weekday();
      return DateHelper2.intervals("day", clampStart, clampEnd).map(function(ts) {
        var weekday2 = DateHelper2.date(ts).weekday();
        if (weekday2 === pivotDay) {
          x += 1;
        }
        return {
          t: ts,
          x,
          y: weekday2
        };
      });
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("day").valueOf();
    }
  };
};
var weekTemplate = function weekTemplate2(DateHelper2, _ref) {
  var domain = _ref.domain;
  var ALLOWED_DOMAIN_TYPE = ["year", "month"];
  return {
    name: "week",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return 1;
    },
    columnsCount: function columnsCount(ts) {
      switch (domain.type) {
        case "year":
          return domain.dynamicDimension ? DateHelper2.date(ts).endOf("year").isoWeeksInYear() : 53;
        case "month":
          return domain.dynamicDimension ? DateHelper2.getWeeksCountInMonth(ts) : 5;
        default:
          return 1;
      }
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      var clampStart = DateHelper2.getFirstWeekOfMonth(startTimestamp);
      var clampEnd = DateHelper2.getFirstWeekOfMonth(endTimestamp);
      return DateHelper2.intervals("week", clampStart, clampEnd).map(function(ts, i) {
        return {
          t: ts,
          x: i,
          y: 0
        };
      });
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("week").valueOf();
    }
  };
};
var monthTemplate = function monthTemplate2(DateHelper2) {
  var ALLOWED_DOMAIN_TYPE = ["year"];
  return {
    name: "month",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return 1;
    },
    columnsCount: function columnsCount() {
      return 12;
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        DateHelper2.intervals("month", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts) {
          return {
            t: ts,
            x: DateHelper2.date(ts).month(),
            y: 0
          };
        })
      );
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("month").valueOf();
    }
  };
};
var yearTemplate = function yearTemplate2(DateHelper2) {
  var ALLOWED_DOMAIN_TYPE = [];
  return {
    name: "year",
    allowedDomainType: ALLOWED_DOMAIN_TYPE,
    rowsCount: function rowsCount() {
      return 1;
    },
    columnsCount: function columnsCount() {
      return 1;
    },
    mapping: function mapping(startTimestamp, endTimestamp) {
      return (
        // eslint-disable-next-line implicit-arrow-linebreak
        DateHelper2.intervals("year", startTimestamp, DateHelper2.date(endTimestamp)).map(function(ts, index) {
          return {
            t: ts,
            x: index,
            y: 0
          };
        })
      );
    },
    extractUnit: function extractUnit(ts) {
      return DateHelper2.date(ts).startOf("year").valueOf();
    }
  };
};
var DefaultTemplates = [minuteTemplate, hourTemplate, dayTemplate$2, dayTemplate$1, dayTemplate3, weekTemplate, monthTemplate, yearTemplate];
var TemplateCollection = function() {
  function TemplateCollection2(dateHelper, options) {
    _classCallCheck(this, TemplateCollection2);
    this.settings = /* @__PURE__ */ new Map();
    this.dateHelper = dateHelper;
    this.options = options;
    this.initiated = false;
  }
  _createClass(TemplateCollection2, [{
    key: "get",
    value: function get2(subDomainType) {
      return this.settings.get(subDomainType);
    }
  }, {
    key: "has",
    value: function has2(subDomainType) {
      return this.settings.has(subDomainType);
    }
  }, {
    key: "init",
    value: function init() {
      if (!this.initiated) {
        this.initiated = true;
        this.add(DefaultTemplates);
      }
    }
  }, {
    key: "add",
    value: function add(templates) {
      var _this = this;
      this.init();
      var tplWithParent = [];
      castArray(templates).forEach(function(f) {
        var template = f(_this.dateHelper, _this.options.options);
        _this.settings.set(template.name, template);
        if (template.hasOwnProperty("parent")) {
          tplWithParent.push(template.name);
        }
      });
      tplWithParent.forEach(function(name) {
        var parentTemplate = _this.settings.get(_this.settings.get(name).parent);
        if (!parentTemplate) {
          return;
        }
        _this.settings.set(name, Object.assign(Object.assign({}, parentTemplate), _this.settings.get(name)));
      });
    }
  }]);
  return TemplateCollection2;
}();
var CalHeatmap = function() {
  function CalHeatmap2() {
    _classCallCheck(this, CalHeatmap2);
    this.options = new Options();
    this.dateHelper = new DateHelper();
    this.templateCollection = new TemplateCollection(this.dateHelper, this.options);
    this.dataFetcher = new DataFetcher(this);
    this.navigator = new Navigator(this);
    this.populator = new Populator(this);
    this.calendarPainter = new CalendarPainter(this);
    this.eventEmitter = new EventEmitter();
    this.pluginManager = new PluginManager(this);
  }
  _createClass(CalHeatmap2, [{
    key: "createDomainCollection",
    value: function createDomainCollection(startDate, range3) {
      var excludeEnd = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return new DomainCollection(this.dateHelper, this.options.options.domain.type, startDate, range3, excludeEnd);
    }
    // =========================================================================
    // PUBLIC API
    // =========================================================================
    /**
     * Setup and paint the calendar with the given options
     *
     * @param  {Object} options The Options object
     * @return A Promise, which will fulfill once all the underlying asynchronous
     * tasks settle, whether resolved or rejected.
     */
  }, {
    key: "paint",
    value: function paint(options, plugins) {
      return __awaiter(this, void 0, void 0, _regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.options.init(options);
              _context.next = 3;
              return this.dateHelper.setup(this.options);
            case 3:
              this.templateCollection.init();
              _context.prev = 4;
              validate(this.templateCollection, this.options.options);
              _context.next = 11;
              break;
            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](4);
              return _context.abrupt("return", Promise.reject(_context.t0));
            case 11:
              if (plugins) {
                this.pluginManager.add(castArray(plugins));
              }
              this.calendarPainter.setup();
              this.domainCollection = new DomainCollection(this.dateHelper);
              this.navigator.loadNewDomains(this.createDomainCollection(this.options.options.date.start, this.options.options.range));
              return _context.abrupt("return", Promise.allSettled([this.calendarPainter.paint(), this.fill()]));
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[4, 8]]);
      }));
    }
    /**
     * Add a new subDomainTemplate
     *
     * @since 4.0.0
     * @param  {SubDomainTemplate[] | SubDomainTemplate} templates
     * A single, or an array of SubDomainTemplate object
     * @return void
     */
  }, {
    key: "addTemplates",
    value: function addTemplates(templates) {
      this.templateCollection.add(templates);
    }
    /**
     * Shift the calendar by n domains forward
     *
     * @param {number} n Number of domain intervals to shift forward
     * @return A Promise, which will fulfill once all the underlying asynchronous
     * tasks settle, whether resolved or rejected.
     */
  }, {
    key: "next",
    value: function next2() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      var loadDirection = this.navigator.loadNewDomains(this.createDomainCollection(this.domainCollection.max, n + 1).slice(n), ScrollDirection.SCROLL_FORWARD);
      return Promise.allSettled([this.calendarPainter.paint(loadDirection), this.fill()]);
    }
    /**
     * Shift the calendar by n domains backward
     *
     * @param {number} n Number of domain intervals to shift backward
     * @return A Promise, which will fulfill once all the underlying asynchronous
     * tasks settle, whether resolved or rejected.
     */
  }, {
    key: "previous",
    value: function previous() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      var loadDirection = this.navigator.loadNewDomains(this.createDomainCollection(this.domainCollection.min, -n), ScrollDirection.SCROLL_BACKWARD);
      return Promise.allSettled([this.calendarPainter.paint(loadDirection), this.fill()]);
    }
    /**
     * Jump directly to a specific date
     *
     * JumpTo will scroll the calendar until the wanted domain with the specified
     * date is visible. Unless you set reset to true, the wanted domain
     * will not necessarily be the first domain of the calendar.
     *
     * @param {Date} date Jump to the domain containing that date
     * @param {boolean} reset Whether the wanted domain
     * should be the first domain of the calendar
     * @return A Promise, which will fulfill once all the underlying asynchronous
     * tasks settle, whether resolved or rejected.
     */
  }, {
    key: "jumpTo",
    value: function jumpTo(date) {
      var reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return Promise.allSettled([this.calendarPainter.paint(this.navigator.jumpTo(date, reset)), this.fill()]);
    }
    /**
     * Fill the calendar with the given data
     *
     * @param  {Object|string}    dataSource    The calendar's datasource,
     * same type as `options.data.source`
     * @return A Promise, which will fulfill once all the underlying asynchronous
     * tasks settle, whether resolved or rejected.
     */
  }, {
    key: "fill",
    value: function fill3() {
      var _this = this;
      var dataSource = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.options.data.source;
      var options = this.options.options;
      var template = this.templateCollection;
      var endDate = this.dateHelper.intervals(options.domain.type, this.domainCollection.max, 2)[1];
      var dataPromise = this.dataFetcher.getDatas(dataSource, this.domainCollection.min, endDate);
      return new Promise(function(resolve2, reject2) {
        dataPromise.then(function(data2) {
          _this.domainCollection.fill(data2, options.data, template.get(options.subDomain.type).extractUnit);
          _this.populator.populate();
          resolve2(null);
        }, function(error) {
          reject2(error);
        });
      });
    }
    /**
     * Listener for all events
     *
     * @since 4.0.0
     * @param  {string}  eventName  Name of the event to listen to
     * @param  {function} Callback function to execute on event trigger
     * @return void
     */
  }, {
    key: "on",
    value: function on(name, fn) {
      this.eventEmitter.on(name, fn);
    }
  }, {
    key: "dimensions",
    value: function dimensions() {
      return this.calendarPainter.dimensions;
    }
    /**
     * Destroy the calendar
     *
     * @since  3.3.6
     * @return A Promise, which will fulfill once all the underlying asynchronous
     * tasks settle, whether resolved or rejected.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      return this.calendarPainter.destroy();
    }
  }, {
    key: "extendDayjs",
    value: function extendDayjs(plugin) {
      return this.dateHelper.extend(plugin);
    }
  }]);
  return CalHeatmap2;
}();
CalHeatmap.VERSION = VERSION;
export {
  CalHeatmap as default
};
//# sourceMappingURL=cal-heatmap.js.map
